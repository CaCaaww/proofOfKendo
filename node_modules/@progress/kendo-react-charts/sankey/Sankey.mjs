/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as e from "react";
import { sankeyTheme as W, Sankey as I } from "@progress/kendo-charts";
import { validatePackage as K, useRtl as M, useDocument as V, canUseDOM as A, WatermarkOverlay as F } from "@progress/kendo-react-common";
import { packageMetadata as U } from "../package-metadata.mjs";
import { sankeyPropTypes as $ } from "./propTypes.mjs";
import { NodeTooltipContent as j, LinkTooltipContent as q, TooltipComponent as z } from "./SankeyTooltip.mjs";
const P = 12, f = {
  offset: P,
  visible: !0
}, B = ["nodeEnter", "nodeLeave", "linkEnter", "linkLeave", "nodeClick", "linkClick"], G = (n, u) => {
  n && (n.unbind(), B.forEach((s) => {
    u[s] && n.bind(s, u[s]);
  }));
}, w = e.forwardRef((n, u) => {
  const s = !K(U, { component: "Sankey" }), l = e.useRef(null), o = e.useRef(null), c = M(l, n.dir, [n.dir, l.current]), k = e.useRef(null), m = V(l), {
    data: y,
    links: v,
    nodes: E,
    labels: b,
    title: C,
    legend: g,
    tooltip: d = f,
    disableAutoLayout: T,
    disableKeyboardNavigation: L
  } = n, R = e.useRef(void 0);
  R.current = n;
  const [h, N] = e.useState(null), S = e.useCallback(
    (r) => {
      const {
        visible: a,
        appendTo: t = m().body,
        offset: p = P,
        nodeComponent: x = j,
        linkComponent: D = q
      } = { ...f, ...d };
      if (a) {
        const H = {
          appendTo: t,
          event: r,
          offset: p,
          dir: c,
          Content: r.targetType === "node" ? x : D
        };
        N(H);
      }
    },
    [d, c, m]
  ), O = e.useCallback(() => {
    N(null);
  }, []), i = e.useCallback((r, a) => {
    const t = R.current[r];
    if (t) {
      const p = {
        ...a,
        nativeEvent: a.originalEvent,
        target: k.current
      };
      t.call(void 0, p);
    }
  }, []);
  return e.useEffect(() => {
    const r = {
      data: y,
      links: v,
      nodes: E,
      labels: b,
      title: C,
      legend: g,
      disableAutoLayout: T,
      disableKeyboardNavigation: L,
      rtl: c === "rtl",
      tooltip: { ...f, ...d }
    };
    if (o.current)
      o.current.setOptions(r);
    else if (A && l.current) {
      const a = W(l.current);
      o.current = new I(l.current, r, a), G(o.current, {
        nodeEnter: (t) => {
          i("onNodeEnter", t);
        },
        nodeLeave: (t) => {
          i("onNodeLeave", t);
        },
        linkEnter: (t) => {
          i("onLinkEnter", t);
        },
        linkLeave: (t) => {
          i("onLinkLeave", t);
        },
        nodeClick: (t) => {
          i("onNodeClick", t);
        },
        linkClick: (t) => {
          i("onLinkClick", t);
        }
      }), o.current.bind("tooltipShow", S), o.current.bind("tooltipHide", O);
    }
    return () => {
      o.current && (o.current.destroy(), o.current = null);
    };
  }, [
    y,
    v,
    E,
    b,
    C,
    g,
    T,
    L,
    c,
    d,
    O,
    S,
    i
  ]), e.useImperativeHandle(
    k,
    () => ({
      get element() {
        return l.current;
      },
      exportVisual: (r) => o.current.exportVisual(r),
      props: n
    }),
    []
  ), e.useImperativeHandle(u, () => k.current), /* @__PURE__ */ e.createElement(e.Fragment, null, /* @__PURE__ */ e.createElement("div", { ref: l, className: n.className, style: n.style, dir: c }), h && /* @__PURE__ */ e.createElement(z, { ...h }), s && /* @__PURE__ */ e.createElement(F, null));
});
w.propTypes = $;
w.displayName = "KendoReactSankey";
export {
  w as Sankey
};
