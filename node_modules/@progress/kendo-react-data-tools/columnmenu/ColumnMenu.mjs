/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as e from "react";
import { Popup as de } from "@progress/kendo-react-popup";
import { useLocalization as Ce } from "@progress/kendo-react-intl";
import { isCompositeFilterDescriptor as pe } from "@progress/kendo-data-query";
import { ColumnMenuItem as R } from "./ColumnMenuItem.mjs";
import { ColumnMenuTextFilter as H, ColumnMenuNumericFilter as J, ColumnMenuDateFilter as K, ColumnMenuBooleanFilter as ge } from "./ColumnMenuFilters.mjs";
import { ColumnMenuFilterLogic as B } from "./ColumnMenuFilterLogic.mjs";
import { ColumnMenuFilterForm as ke } from "./ColumnMenuFilterForm.mjs";
import { columnMenuSortAscending as Q, messages as A, columnMenuSortDescending as U, columnMenuFilterTitle as V } from "../messages/index.mjs";
import { validatePackage as Fe, IconWrap as ve, WatermarkOverlay as he } from "@progress/kendo-react-common";
import { packageMetadata as be } from "../package-metadata.mjs";
import { sortAscSmallIcon as Ee, sortDescSmallIcon as Me, filterIcon as X } from "@progress/kendo-svg-icons";
const b = (o) => {
  const m = !Fe(be, { component: "ColumnMenu" }), f = e.useRef([]), {
    field: t,
    filter: n,
    sort: u = f.current,
    onSortChange: s,
    onFilterChange: k,
    initialFilter: p,
    sortAsc: y = !1,
    sortDesc: L = !1,
    filterContent: T = [],
    expandFilters: E = !1
  } = o, [d, q] = e.useState(!1), [M, N] = e.useState(E), [r, v] = e.useState(t && p ? p(t) : null), S = e.useRef(null), w = e.useRef(null), x = e.useRef(null), D = e.useRef(!1), g = e.useCallback(
    () => (n || []).find(
      (l) => l.filters.every((i) => !pe(i) && i.field === t)
    ),
    [n, t]
  ), C = e.useCallback(() => {
    q(!1);
  }, []), Y = e.useCallback(() => {
    if (D.current) {
      D.current = !1;
      return;
    }
    clearTimeout(x.current), x.current = window.setTimeout(() => {
      C();
    });
  }, [C]), Z = e.useCallback(() => clearTimeout(x.current), []), $ = e.useCallback(
    (l) => {
      D.current = d && l.currentTarget === S.current;
    },
    [d]
  ), ee = e.useCallback(() => {
    q(!d), t && p && (N(d ? !1 : E), v(d ? r : g() || p(t)));
  }, [g, t, d, r, p, E]);
  e.useEffect(() => {
    d && w.current && w.current.focus();
  }, [d]);
  const te = e.useCallback(() => N(!M), [M]), h = e.useCallback(
    (l, i) => {
      const c = [...u], a = c.findIndex((fe) => fe.field === t), F = { field: t, dir: i };
      a >= 0 ? c[a].dir !== F.dir ? c.splice(a, 1, F) : c.splice(a, 1) : c.push(F), C(), s && s.call(void 0, l, c, t);
    },
    [u, t, s, C]
  ), O = e.useCallback(
    (l, i, c) => {
      const a = { ...r, filters: [...r.filters] }, F = a.filters.indexOf(c);
      a.filters.splice(F, 1, i), v(a);
    },
    [r]
  ), ne = e.useCallback(
    (l) => {
      l.preventDefault();
      const i = (n || []).slice(), c = g(), a = c ? i.indexOf(c) : -1;
      a >= 0 ? i.splice(a, 1, r) : i.push(r), C(), k && k.call(void 0, l, i, t);
    },
    [n, r, t, k, C, g]
  ), le = e.useCallback(
    (l) => {
      const i = (n || []).slice(), c = g(), a = c ? i.indexOf(c) : -1;
      a >= 0 && i.splice(a, 1), p && v(p(t)), C(), k && k.call(void 0, l, i, t);
    },
    [n, t, k, p, C, g]
  ), oe = e.useCallback(
    (l) => h(l, "asc"),
    [h]
  ), re = e.useCallback(
    (l) => h(l, "desc"),
    [h]
  ), ie = e.useCallback(
    (l) => r && v({ ...r, logic: l.value.logic }),
    [r]
  ), W = u.find((l) => l.field === t) || { dir: "" }, [z, P, _] = T, I = Ce(), se = y || L ? /* @__PURE__ */ e.createElement("div", { className: "k-columnmenu-item-wrapper", key: "sorting" }, y && /* @__PURE__ */ e.createElement(
    R,
    {
      title: I.toLanguageString(
        Q,
        A[Q]
      ),
      iconClass: "k-i-sort-asc-small",
      svgIcon: Ee,
      selected: W.dir === "asc",
      onClick: oe
    }
  ), L && /* @__PURE__ */ e.createElement(
    R,
    {
      title: I.toLanguageString(
        U,
        A[U]
      ),
      iconClass: "k-i-sort-desc-small",
      svgIcon: Me,
      selected: W.dir === "desc",
      onClick: re
    }
  )) : null, ce = r && T.length > 0 ? /* @__PURE__ */ e.createElement("div", { className: "k-columnmenu-item-wrapper", key: "filtering" }, /* @__PURE__ */ e.createElement(
    R,
    {
      iconClass: "k-i-filter",
      svgIcon: X,
      title: I.toLanguageString(V, A[V]),
      onClick: te
    }
  ), /* @__PURE__ */ e.createElement(ke, { show: M, onSubmit: ne, onReset: le }, z && /* @__PURE__ */ e.createElement(
    z,
    {
      filter: r.filters[0],
      onFilterChange: O
    }
  ), P && /* @__PURE__ */ e.createElement(P, { value: r.logic, onChange: ie }), _ && /* @__PURE__ */ e.createElement(
    _,
    {
      filter: r.filters[1],
      onFilterChange: O
    }
  ))) : null, j = [se, ce], ae = /* @__PURE__ */ e.createElement(
    "span",
    {
      ref: S,
      onClick: ee,
      onMouseDown: $,
      className: "k-grid-header-menu k-grid-column-menu" + (g() ? " k-active" : ""),
      key: "button"
    },
    /* @__PURE__ */ e.createElement(ve, { name: "filter", icon: X })
  ), ue = /* @__PURE__ */ e.createElement(de, { anchor: S.current, show: d, key: "popup", popupClass: "k-column-menu k-column-menu-popup" }, /* @__PURE__ */ e.createElement("div", { ref: w, tabIndex: 0, onBlur: Y, onFocus: Z, style: { outline: "none" } }, o.itemsRender ? o.itemsRender.call(void 0, j, { closeMenu: C, field: t }) : j)), me = m ? /* @__PURE__ */ e.createElement(he, null) : /* @__PURE__ */ e.createElement(e.Fragment, null), G = [ae, ue, me];
  return /* @__PURE__ */ e.createElement(e.Fragment, null, o.render ? o.render.call(void 0, G) : G);
}, qe = (o) => {
  const { field: m, ...f } = o, t = e.useCallback(
    (s) => ({
      logic: "and",
      filters: [
        { operator: "contains", field: s, value: "" },
        { operator: "contains", field: s, value: "" }
      ]
    }),
    []
  ), n = !!o.field, u = n ? [H, B, H] : [];
  return /* @__PURE__ */ e.createElement(
    b,
    {
      sortAsc: n,
      sortDesc: n,
      filterContent: u,
      initialFilter: n ? t : void 0,
      field: m,
      ...f
    }
  );
}, Ne = (o) => {
  const { field: m, ...f } = o, t = e.useCallback(
    (s) => ({
      logic: "or",
      filters: [
        { operator: "eq", field: s, value: null },
        { operator: "eq", field: s, value: null }
      ]
    }),
    []
  ), n = !!o.field, u = n ? [J, B, J] : [];
  return /* @__PURE__ */ e.createElement(
    b,
    {
      sortAsc: n,
      sortDesc: n,
      filterContent: u,
      initialFilter: n ? t : void 0,
      field: m,
      ...f
    }
  );
}, Oe = (o) => {
  const { field: m, ...f } = o, t = e.useCallback(
    (s) => ({
      logic: "or",
      filters: [
        { operator: "eq", field: s, value: null },
        { operator: "eq", field: s, value: null }
      ]
    }),
    []
  ), n = !!o.field, u = n ? [K, B, K] : [];
  return /* @__PURE__ */ e.createElement(
    b,
    {
      sortAsc: n,
      sortDesc: n,
      filterContent: u,
      initialFilter: n ? t : void 0,
      field: m,
      ...f
    }
  );
}, We = (o) => {
  const { field: m, ...f } = o, t = e.useCallback(
    (s) => ({
      logic: "and",
      filters: [{ operator: "eq", field: s, value: !1 }]
    }),
    []
  ), n = !!o.field, u = n ? [ge] : [];
  return /* @__PURE__ */ e.createElement(
    b,
    {
      sortAsc: n,
      sortDesc: n,
      filterContent: u,
      initialFilter: n ? t : void 0,
      field: m,
      ...f
    }
  );
};
export {
  We as ColumnMenuBooleanColumn,
  Oe as ColumnMenuDateColumn,
  Ne as ColumnMenuNumericColumn,
  qe as ColumnMenuTextColumn
};
