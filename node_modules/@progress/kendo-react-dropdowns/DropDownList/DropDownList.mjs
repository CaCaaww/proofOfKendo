/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as i from "react";
import E from "prop-types";
import { usePropsContext as Yt, validatePackage as $t, useUnstyled as jt, useId as Jt, canUseDOM as nt, useAdaptiveModeContext as Qt, classNames as C, uDropDownList as L, getTabIndex as Xt, IconWrap as Zt, svgIconPropType as Rt, createPropsContext as en, Keys as w, uDropDownsActionSheet as j, WatermarkOverlay as tn } from "@progress/kendo-react-common";
import { FloatingLabel as nn } from "@progress/kendo-react-labels";
import { caretAltDownIcon as rn, xIcon as on } from "@progress/kendo-svg-icons";
import an from "../common/ListContainer.mjs";
import sn from "../common/ListFilter.mjs";
import rt from "../common/GroupStickyHeader.mjs";
import ln from "../common/ListDefaultItem.mjs";
import dn from "../common/List.mjs";
import lt from "../common/DropDownBase.mjs";
import { getFilteredData as b, areSame as M, getItemValue as me, isPresent as ot, itemIndexStartsWith as cn, sameCharsOnly as un, shuffleData as pn, matchText as it } from "../common/utils.mjs";
import { packageMetadata as mn } from "../package-metadata.mjs";
import { Button as at } from "@progress/kendo-react-buttons";
import { useLocalization as fn } from "@progress/kendo-react-intl";
import { dropDownListArrowBtnAriaLabel as st, messages as vn } from "../messages/index.mjs";
import { ActionSheet as gn, ActionSheetHeader as hn, ActionSheetContent as In } from "@progress/kendo-react-layout";
const yn = "Please select a value from the list!", Ke = i.forwardRef((dt, ct) => {
  let Te = !1;
  const n = Yt(wn, dt), {
    delay: ut = T.delay,
    tabIndex: pt = T.tabIndex,
    ignoreCase: fe = T.ignoreCase,
    size: J = T.size,
    rounded: ze = T.rounded,
    fillMode: ve = T.fillMode,
    groupMode: xn = T.groupMode
  } = n;
  if (n.filterable || n.virtual) {
    const e = [];
    n.filterable && e.push("filterable"), n.virtual && e.push("virtualization"), Te = !$t(mn, {
      component: "DropDownList",
      features: e
    });
  }
  const N = jt(), ge = Jt(n.id), he = () => {
    var e;
    if (nt)
      return ((e = X.current) == null ? void 0 : e.ownerDocument) || window.document;
  }, mt = () => {
    var e, r;
    (e = t == null ? void 0 : t.current) != null && e.wrapper && ((r = t == null ? void 0 : t.current) == null || r.wrapper.focus({ preventScroll: !0 }));
  }, k = () => {
    let e;
    return A.current !== void 0 && A.current !== null ? e = A.current : n.value !== void 0 ? e = n.value : p.value !== void 0 && p.value !== null ? e = p.value : n.defaultValue !== void 0 && n.defaultValue !== null && (e = n.defaultValue), !ot(e) && n.defaultItem !== void 0 && n.defaultItem !== null && (e = n.defaultItem), e;
  }, ft = () => {
    const { dataItemKey: e } = n, r = b(n), a = k();
    return r.findIndex((c) => M(c, a, e));
  }, Ie = () => n.required !== void 0 ? n.required : T.required, ye = () => {
    const e = n.validationMessage !== void 0, r = k(), a = !Ie() || r !== null && r !== "" && r !== void 0, c = n.valid !== void 0 ? n.valid : a;
    return {
      customError: e,
      valid: c,
      valueMissing: r === null
    };
  }, vt = () => n.validityStyles !== void 0 ? n.validityStyles : T.validityStyles, re = (e) => {
    oe.current = !0, e.focus(), window.setTimeout(() => oe.current = !1, 30);
  }, we = () => {
    Z.current && re(Z.current), n.adaptive && setTimeout(() => {
      Z.current && re(Z.current);
    }, 300);
  }, gt = i.useCallback((e) => {
    for (const r of e)
      Tt(r.target.clientWidth);
  }, []), Oe = () => {
    var e;
    (e = Ce.current) != null && e.setCustomValidity && Ce.current.setCustomValidity(
      ye().valid ? "" : n.validationMessage || yn
    );
  }, q = (e, r) => {
    const a = k();
    M(a, e, n.dataItemKey) || (n.value === void 0 && (r.data.value = e), t.current.updateComponentArgs({ value: e }), A.current = e, r.events.push({ type: "onChange" }));
  }, F = (e) => {
    var r;
    (r = t == null ? void 0 : t.current) == null || r.applyState(e), A.current = void 0;
  }, Q = (e, r) => {
    var l;
    const { virtual: a, dataItemKey: c, defaultItem: u } = n, m = b(n), v = a ? a.skip : 0, f = k(), o = e === -1 && u !== void 0 ? u : m[e - v], d = !M(o, f, c);
    q(o, r), d && ((l = t == null ? void 0 : t.current) == null || l.triggerPageChangeCornerItems(o, r));
  }, O = (e, r, a) => {
    var I, h;
    const { defaultItem: c, dataItemKey: u, virtual: m = { skip: 0, total: 0, pageSize: 0 } } = n, v = k(), f = b(n), o = (I = t == null ? void 0 : t.current) == null ? void 0 : I.vs, d = f.findIndex((y) => M(y, v, u)), l = (h = t == null ? void 0 : t.current) == null ? void 0 : h.navigation.navigate({
      current: m.skip + d,
      max: (o != null && o.enabled ? m.total : f.length) - 1,
      min: c !== void 0 ? -1 : 0,
      keyCode: r,
      skipItems: a || void 0
    });
    l !== void 0 && Q(l, e), F(e);
  }, ht = (e) => {
    X.current = e, t.current.wrapper = e;
  }, It = (e) => /* @__PURE__ */ i.createElement(
    "select",
    {
      name: n.name,
      ref: (r) => {
        Ce.current = r;
      },
      tabIndex: -1,
      "aria-hidden": !0,
      title: n.label,
      style: { opacity: 0, width: 1, border: 0, zIndex: -1, position: "absolute", left: "50%" }
    },
    /* @__PURE__ */ i.createElement("option", { value: n.valueMap ? n.valueMap.call(void 0, e) : e })
  ), xe = () => {
    const {
      textField: e,
      dataItemKey: r,
      virtual: a = { skip: 0 },
      focusedItemIndex: c = cn,
      filterable: u,
      skipDisabledItems: m = !0
    } = n, v = k(), f = b(n), o = n.filter ? n.filter : p.text;
    return m && e && !o && !v ? f.findIndex((d) => !d.disabled && d[e]) : ot(v) && o === void 0 || u && o === "" ? f.findIndex((d) => M(d, v, r)) : o ? Ee.current ? c(f, o, e) : f.findIndex((d) => M(d, v, r)) : a.skip === 0 ? 0 : -1;
  }, Ae = (e, r) => r !== void 0 && r !== -1 && e && e.length > 0 && e[r].disabled, De = () => {
    const e = b(n), r = t.current.initState(), a = xe();
    Ae(e, a) && (q(null, r), F(r));
  }, Se = (e) => {
    if (e.isPropagationStopped())
      return;
    const r = t.current.initState();
    r.syntheticEvent = e, p.focused || (r.data.focused = !0), De(), t.current.togglePopup(r), F(r);
  }, He = (e) => {
    var z, ue, W, pe, $, et, tt;
    e && e.target instanceof Element && e.target.nodeName === "INPUT" && e.stopPropagation && e.stopPropagation();
    const {
      filterable: r,
      disabled: a,
      defaultItem: c,
      leftRightKeysNavigation: u = !0,
      virtual: m = { skip: 0, total: 0, pageSize: 0 },
      dataItemKey: v,
      groupField: f = "",
      textField: o,
      skipDisabledItems: d = !0
    } = n, l = b(n), I = k(), h = l.findIndex((S) => M(S, I, v)), y = n.opened !== void 0 ? n.opened : p.opened, s = e.keyCode, K = s === w.home || s === w.end, P = s === w.up || s === w.down, Y = !y && (e.altKey && s === w.down || s === w.enter || s === w.space), ne = y && (e.altKey && s === w.up || s === w.esc), de = u && (s === w.left || s === w.right), ce = P || de && !r || K, D = t.current.initState();
    if (D.syntheticEvent = e, !a) {
      if (K && ((z = t == null ? void 0 : t.current) != null && z.vs.enabled))
        s === w.home ? m.skip !== 0 ? ((ue = t == null ? void 0 : t.current) == null || ue.triggerOnPageChange(D, 0, m.pageSize), H.current = !0) : q(l[0], D) : m.skip < m.total - m.pageSize ? ((W = t == null ? void 0 : t.current) == null || W.triggerOnPageChange(
          D,
          m.total - m.pageSize,
          m.pageSize
        ), H.current = !0) : q(l[l.length - 1], D);
      else if (y && s === w.pageUp)
        e.preventDefault(), (pe = t == null ? void 0 : t.current) == null || pe.scrollPopupByPageSize(-1);
      else if (y && s === w.pageDown)
        e.preventDefault(), ($ = t == null ? void 0 : t.current) == null || $.scrollPopupByPageSize(1);
      else if (y && s === w.enter) {
        const S = xe();
        Ae(l, S) ? (q(null, D), F(D)) : Q(S, D), (et = t == null ? void 0 : t.current) == null || et.togglePopup(D), e.preventDefault();
      } else if (Y || ne)
        ne && De(), (tt = t == null ? void 0 : t.current) == null || tt.togglePopup(D), e.preventDefault();
      else if (ce) {
        if (Ee.current = !1, f !== "" && o)
          if (!d && y)
            O(D, s);
          else {
            let S;
            if (s === w.down || s === w.right) {
              const x = l.slice(h + 1).find((g) => !g.disabled && g[o]);
              S = x && l.findIndex((g) => g[o] === x[o]);
            } else if (s === w.up || s === w.left) {
              let x;
              if (h === 0 && c)
                S = -1;
              else if (h === -1)
                x = l, S = l.findIndex((g) => !g.disabled && g[o]);
              else {
                x = l.slice(0, h);
                let g = x.pop();
                for (; g && g.disabled; )
                  g = x.pop();
                S = g && l.findIndex((Fe) => Fe[o] === g[o]);
              }
            }
            if (S !== void 0) {
              const x = S - h;
              O(D, s, x);
            } else S === void 0 && l.findIndex((x) => x[o] === I[o]) === l.length - 1 && O(D, s);
          }
        else if (!d && y || K)
          O(D, s);
        else if (o) {
          let S;
          if (s === w.down || s === w.right) {
            const x = l.slice(h + 1).find((g) => !g.disabled && g[o]);
            S = x && l.findIndex((g) => g[o] === x[o]);
          } else if (s === w.up || s === w.left) {
            let x;
            if (h === 0 && c)
              S = -1;
            else if (h === -1)
              x = l, S = l.find((g) => !g.disabled && g[o]);
            else {
              x = l.slice(0, h);
              let g = x.pop();
              for (; g && g.disabled; )
                g = x.pop();
              S = g && l.findIndex((Fe) => Fe[o] === g[o]);
            }
          }
          if (S !== void 0) {
            const x = S - h;
            O(D, s, x);
          } else S === void 0 && l.findIndex((x) => x[o] === I[o]) === l.length - 1 && O(D, s);
        } else
          O(D, s);
        e.preventDefault();
      }
      F(D);
    }
  }, yt = (e) => {
    const r = t.current.initState();
    r.syntheticEvent = e.syntheticEvent, n.filter === void 0 && (r.data.text = e.target.value), t.current.filterChanged(e.target.value, r), Ee.current = !0, F(r), ee({ group: void 0, text: String(e.target.value) });
  }, Ve = () => {
    const e = n.filter !== void 0 ? n.filter : p.text;
    return n.filterable && /* @__PURE__ */ i.createElement(
      sn,
      {
        value: e,
        ref: (r) => {
          Z.current = r && r.element;
        },
        onChange: yt,
        onKeyDown: He,
        size: J,
        rounded: ze,
        fillMode: ve,
        renderListFilterWrapper: !0
      }
    );
  }, wt = (e) => {
    var a;
    const r = t.current.initState();
    r.syntheticEvent = e, (a = t == null ? void 0 : t.current) == null || a.togglePopup(r), q(n.defaultItem, r), F(r);
  }, Be = () => {
    const { textField: e, defaultItem: r, dataItemKey: a } = n, c = k();
    return r !== void 0 && /* @__PURE__ */ i.createElement(
      ln,
      {
        defaultItem: r,
        textField: e,
        selected: M(c, r, a),
        key: "defaultitemkey",
        onClick: wt
      }
    );
  }, xt = (e, r) => {
    var a;
    (a = t == null ? void 0 : t.current) == null || a.handleItemClick(e, r), A.current = void 0;
  }, Dt = (e) => {
    const { vs: r, list: a } = t.current;
    r.scrollHandler(e);
    const { groupField: c } = n;
    let u = b(n);
    if (!(!c || !u.length) && c) {
      const m = _e.current = _e.current || (r.enabled ? r.itemHeight : a ? a.children[0].offsetHeight : 0), f = e.target.scrollTop - r.skip * m;
      u = t.current.getGroupedDataModernMode(u, c);
      let o = u[0][c];
      for (let d = 1; d < u.length && !(m * d > f); d++)
        u[d] && u[d][c] && (o = u[d][c]);
      o !== p.group && ee({ group: o });
    }
  }, We = () => {
    var s;
    const {
      textField: e,
      dataItemKey: r,
      virtual: a = { skip: 0, total: void 0 },
      groupHeaderItemRender: c,
      listNoDataRender: u,
      itemRender: m
    } = n, v = b(n), f = N && N.uDropDownList, o = t.current.vs, d = a.skip, l = n.opened !== void 0 ? n.opened : p.opened, I = t.current.getPopupSettings(), h = `translateY(${o.translate}px)`, y = k();
    return /* @__PURE__ */ i.createElement(
      dn,
      {
        id: Le,
        show: l,
        data: v.slice(),
        focusedIndex: xe(),
        value: y,
        textField: e,
        valueField: r,
        optionsGuid: $e,
        groupField: n.groupField,
        groupMode: "modern",
        listRef: (K) => {
          o.list = t.current.list = K;
        },
        wrapperStyle: { maxHeight: I.height },
        wrapperCssClass: C(L.listContent({ c: f })),
        listStyle: o.enabled ? { transform: h } : void 0,
        key: "listkey",
        skip: d,
        onClick: xt,
        itemRender: m,
        groupHeaderItemRender: c,
        noDataRender: u,
        onScroll: Dt,
        wrapperRef: o.scrollerRef,
        scroller: (s = t == null ? void 0 : t.current) == null ? void 0 : s.renderScrollElement(),
        ariaSetSize: a.total
      }
    );
  }, St = () => {
    var h;
    const { header: e, footer: r, adaptiveTitle: a, groupField: c, groupStickyHeaderItemRender: u, list: m } = n, v = b(n), f = n.opened !== void 0 ? n.opened : p.opened, o = N && N.uDropDownList, d = N && N.uDropDownsActionSheet, l = {
      navigatable: !1,
      navigatableElements: [],
      expand: f,
      animation: !0,
      onClose: (y) => Se(y),
      className: C(
        j.wrapper({
          c: d
        }),
        "k-adaptive-actionsheet"
      ),
      animationStyles: _ && G && _ <= G.small ? { top: 0, width: "100%", height: "100%" } : void 0,
      position: _ && G && _ <= G.small ? "fullscreen" : void 0
    };
    let { group: I } = p;
    return I === void 0 && c !== void 0 && (I = me(v[0], c)), /* @__PURE__ */ i.createElement(gn, { ...l }, /* @__PURE__ */ i.createElement(hn, { className: C(j.header({ c: d })) }, /* @__PURE__ */ i.createElement("div", { className: C(j.titleBar({ c: d })) }, /* @__PURE__ */ i.createElement("div", { className: C(j.title({ c: d })) }, /* @__PURE__ */ i.createElement("div", null, a)), /* @__PURE__ */ i.createElement("div", { className: C(j.actions({ c: d })) }, /* @__PURE__ */ i.createElement(
      at,
      {
        tabIndex: 0,
        "aria-label": "Cancel",
        "aria-disabled": "false",
        type: "button",
        fillMode: "flat",
        onClick: Se,
        icon: "x",
        svgIcon: on
      }
    ))), /* @__PURE__ */ i.createElement("div", { className: C(j.titleBarGroup({ c: d })) }, Ve())), /* @__PURE__ */ i.createElement(In, null, e && /* @__PURE__ */ i.createElement("div", { className: C(L.listHeader({ c: o })) }, e), /* @__PURE__ */ i.createElement(
      "div",
      {
        className: C(
          L.list({
            c: o,
            size: J,
            virtual: (h = t == null ? void 0 : t.current) == null ? void 0 : h.vs.enabled
          })
        )
      },
      Be(),
      !m && I && v.length !== 0 && /* @__PURE__ */ i.createElement(
        rt,
        {
          group: I,
          groupMode: "modern",
          render: u
        }
      ),
      We()
    ), r && /* @__PURE__ */ i.createElement("div", { className: C(L.listFooter({ c: o })) }, r)));
  }, Ct = () => {
    p.focused && window.setTimeout(() => {
      p.focused && t.current.wrapper && re(t.current.wrapper);
    });
  }, Et = (e) => {
    "onMouseDownOutside" in (n.popupSettings || {}) && n.popupSettings.onMouseDownOutside.call(void 0, e);
  }, kt = () => {
    const { header: e, footer: r, dir: a, groupField: c, groupStickyHeaderItemRender: u, list: m } = n, v = b(n), f = t.current, o = f.getPopupSettings(), d = n.opened !== void 0 ? n.opened : p.opened, l = o.width !== void 0 ? o.width : f.popupWidth, I = N && N.uDropDownList, h = {
      dir: a !== void 0 ? a : f.dirCalculated,
      width: l,
      popupSettings: {
        ...o,
        popupClass: C(
          o.popupClass,
          L.listContainer({
            c: I
          })
        ),
        anchor: o.anchor || X.current,
        show: d,
        onOpen: we,
        onClose: Ct,
        onMouseDownOutside: Et
      },
      itemsCount: [v.length]
    };
    let { group: y } = p;
    return y === void 0 && c !== void 0 && (y = me(v[0], c)), /* @__PURE__ */ i.createElement(an, { ...h }, Ve(), e && /* @__PURE__ */ i.createElement("div", { className: C(L.listHeader({ c: I })) }, e), /* @__PURE__ */ i.createElement(
      "div",
      {
        className: C(
          L.list({
            c: I,
            size: J,
            virtual: t.current.vs.enabled
          })
        )
      },
      Be(),
      !m && y && v.length !== 0 && /* @__PURE__ */ i.createElement(rt, { group: y, groupMode: "modern", render: u }),
      We()
    ), r && /* @__PURE__ */ i.createElement("div", { className: C(L.listFooter({ c: I })) }, r), Te && /* @__PURE__ */ i.createElement(tn, null));
  }, Lt = (e) => {
    const { dataItemKey: r } = n, a = b(n), c = k();
    let u = a.map((P, Y) => ({ item: P, itemIndex: Y }));
    const m = U.current.word, v = U.current.last, f = un(m, v);
    let o = u.length, d = Math.max(
      0,
      a.findIndex((P) => M(P, c, r))
    ), l;
    n.defaultItem && (l = { item: n.defaultItem, itemIndex: -1 }, o += 1, d += 1), d += f ? 1 : 0, u = pn(u, d, l);
    let I, h, y, s = 0;
    const { textField: K } = n;
    for (; s < o; ) {
      if (I = me(u[s].item, K), h = f && it(I, v, fe), y = it(I, m, fe), h || y) {
        s = u[s].itemIndex;
        break;
      }
      s++;
    }
    if (s !== o) {
      const P = t.current.initState();
      P.syntheticEvent = e, Q(s, P), F(P), A.current = void 0;
    }
  }, bt = (e) => {
    clearTimeout(Ue.current), n.filterable || (Ue.current = window.setTimeout(() => U.current.word = "", ut), Lt(e));
  }, Pt = (e) => {
    oe.current || t.current.handleFocus(e);
  }, Mt = (e) => {
    if (oe.current || !p.focused)
      return;
    const r = n.opened !== void 0 ? n.opened : p.opened, a = t.current.initState();
    a.syntheticEvent = e, a.data.focused = !1, a.events.push({ type: "onBlur" }), r && De(), r && !Ne && t.current.togglePopup(a), F(a);
  }, Nt = (e) => {
    if (n.filterable || e.which === 0 || e.keyCode === w.enter)
      return;
    let r = String.fromCharCode(e.charCode || e.keyCode);
    fe && (r = r.toLowerCase()), r === " " && e.preventDefault(), U.current = {
      word: U.current.word + r,
      last: U.current.last + r
    }, bt(e);
  }, Ft = () => {
    const e = t.current.initState();
    e.data.opened = p.opened, t.current.togglePopup(e), F(e);
  }, qe = i.useRef(null), X = i.useRef(null), Ce = i.useRef(null), Z = i.useRef(null);
  i.useImperativeHandle(
    qe,
    () => ({
      get element() {
        return X.current;
      },
      get index() {
        return ft();
      },
      get name() {
        return n.name;
      },
      get validity() {
        return ye();
      },
      get value() {
        return k();
      },
      get focused() {
        return p.focused;
      },
      get opened() {
        return p.opened;
      },
      focus: mt,
      props: n,
      togglePopup: Ft
    })
  ), i.useImperativeHandle(
    ct,
    () => qe.current
  );
  const Ue = i.useRef(null), U = i.useRef({ word: "", last: "" }), oe = i.useRef(!1), A = i.useRef(null), H = i.useRef(!1), Ee = i.useRef(!1), V = i.useRef({}), ke = i.useRef({}), t = i.useRef(
    new lt({
      props: n,
      setState: () => {
      },
      state: {},
      forceUpdate: () => {
      },
      element: null,
      value: null,
      handleItemSelect: () => {
      }
    })
  ), _e = i.useRef(0), R = i.useRef(null), [p, Kt] = i.useState({}), [_, Tt] = i.useState(), [, Ge] = i.useReducer((e) => e, !0), zt = fn(), ee = (e) => {
    Kt({ ...p, ...e });
  };
  i.useEffect(() => {
    t.current.updateComponentArgs({
      props: n,
      setState: ee,
      state: p,
      forceUpdate: Ge,
      element: X.current,
      handleItemSelect: Q,
      value: k()
    });
  }, [ee, p, Ge, Q, k]), i.useEffect(() => {
    var d, l, I, h, y, s, K, P, Y, ne, de, ce, D;
    const { dataItemKey: e, virtual: r, groupField: a = "", textField: c } = n, u = b(n), m = V.current.virtual ? V.current.virtual.total : 0, v = n.opened !== void 0 ? n.opened : p.opened, f = V.current.opened !== void 0 ? V.current.opened : ke.current.opened, o = !f && v;
    if ((d = t == null ? void 0 : t.current) == null || d.didUpdate(), (l = t == null ? void 0 : t.current) != null && l.getPopupSettings().animate || o && we(), r && r.total !== m)
      (I = t == null ? void 0 : t.current) == null || I.vs.calcScrollElementHeight(), (h = t == null ? void 0 : t.current) == null || h.vs.reset();
    else {
      const z = k(), ue = V.current.value !== void 0 ? V.current.value : ke.current.value;
      let W = u.findIndex(($) => M($, z, e));
      a !== "" && z && c && (W = (s = (y = t == null ? void 0 : t.current) == null ? void 0 : y.getGroupedDataModernMode(u, a)) == null ? void 0 : s.map(($) => $[c]).indexOf(z[c]));
      const pe = !M(ue, z, e);
      o && r ? (K = t == null ? void 0 : t.current) == null || K.scrollToVirtualItem(r, W) : o && !r ? (we(), u && u.length !== 0 && ((P = t == null ? void 0 : t.current) == null || P.resetGroupStickyHeader(u[0][a], {
        setState: ee,
        group: p.group,
        state: p
      })), (Y = t == null ? void 0 : t.current) == null || Y.scrollToItem(W)) : v && f && z && pe && !H.current ? (de = t == null ? void 0 : t.current) == null || de.scrollToItem(W, (ne = t == null ? void 0 : t.current) == null ? void 0 : ne.vs.enabled) : v && f && H.current && (H.current && r && r.skip === 0 ? (ce = t == null ? void 0 : t.current) == null || ce.vs.reset() : H.current && r && r.skip === r.total - r.pageSize && ((D = t == null ? void 0 : t.current) == null || D.vs.scrollToEnd()));
    }
    H.current = !1, ke.current = p, V.current = n, Oe();
  }), i.useEffect(() => {
    var e, r;
    return R.current = nt && window.ResizeObserver && new window.ResizeObserver(gt.bind(void 0)), (e = t == null ? void 0 : t.current) == null || e.didMount(), Oe(), (r = he()) != null && r.body && R.current && R.current.observe(he().body), () => {
      var a;
      (a = he()) != null && a.body && R.current && R.current.disconnect();
    };
  }, []);
  const Ye = ge + "-accessibility-id", Le = ge + "-listbox-id", $e = ge + "-guid", Ot = zt.toLanguageString(
    st,
    vn[st]
  ), {
    style: ie,
    className: At,
    label: be,
    dir: Ht,
    virtual: B,
    adaptive: Dn,
    dataItemKey: Vt,
    disabled: ae,
    loading: je,
    iconClassName: Je,
    svgIcon: Bt,
    valueRender: Qe
  } = n, Pe = n.opened !== void 0 ? n.opened : p.opened, se = k(), Me = me(se, n.textField), Xe = !vt() || ye().valid, le = t.current, Wt = le.vs, te = N && N.uDropDownList;
  Wt.enabled = B !== void 0;
  const G = Qt(), Ne = !!(_ && G && _ <= G.medium && n.adaptive);
  B !== void 0 && (le.vs.skip = B.skip, le.vs.total = B.total, le.vs.pageSize = B.pageSize);
  const qt = b(n), { focused: Ut } = p, _t = qt.findIndex((e) => M(e, se, Vt)), Ze = /* @__PURE__ */ i.createElement("span", { id: Ye, className: C(L.inputInner({ c: te })) }, Me && /* @__PURE__ */ i.createElement("span", { className: C(L.inputText({ c: te })) }, Me)), Gt = Qe !== void 0 ? Qe.call(void 0, Ze, se) : Ze, Re = /* @__PURE__ */ i.createElement(i.Fragment, null, /* @__PURE__ */ i.createElement(
    "span",
    {
      ref: ht,
      className: C(
        L.wrapper({
          c: te,
          size: J,
          rounded: ze,
          fillMode: ve,
          focused: Ut,
          disabled: ae,
          invalid: !Xe,
          loading: je,
          required: Ie()
        }),
        At
      ),
      style: be ? { ...ie, width: void 0 } : ie,
      dir: Ht,
      onMouseDown: Pe ? (e) => {
        e.target.nodeName !== "INPUT" && (re(t.current.wrapper), e.preventDefault());
      } : void 0,
      onFocus: Pt,
      onBlur: Mt,
      tabIndex: Xt(pt, ae),
      accessKey: n.accessKey,
      onKeyDown: He,
      onKeyPress: Nt,
      onClick: ae ? void 0 : Se,
      role: "combobox",
      "aria-required": Ie(),
      "aria-disabled": ae || void 0,
      "aria-haspopup": "listbox",
      "aria-expanded": Pe || !1,
      "aria-owns": Le,
      "aria-activedescendant": Pe ? "option-" + $e + "-" + (_t + (B ? B.skip : 0)) : void 0,
      "aria-label": n.ariaLabel || n.label,
      "aria-labelledby": n.ariaLabelledBy,
      "aria-describedby": n.ariaDescribedBy || Ye,
      "aria-controls": Le,
      id: n.id,
      title: n.title
    },
    Gt,
    je && /* @__PURE__ */ i.createElement(Zt, { className: C(L.loadingIcon({ c: te })), name: "loading" }),
    /* @__PURE__ */ i.createElement(
      at,
      {
        tabIndex: -1,
        type: "button",
        "aria-label": Ot,
        size: J,
        fillMode: ve,
        className: C(L.inputButton({ c: te })),
        rounded: null,
        themeColor: "base",
        iconClass: Je,
        svgIcon: Je ? void 0 : Bt || rn,
        onMouseDown: (e) => p.focused && e.preventDefault()
      }
    ),
    It(se),
    !Ne && kt()
  ), Ne && St());
  return be ? /* @__PURE__ */ i.createElement(
    nn,
    {
      label: be,
      editorValue: Me,
      editorValid: Xe,
      editorDisabled: n.disabled,
      style: { width: ie ? ie.width : void 0 },
      children: Re
    }
  ) : Re;
});
Ke.propTypes = {
  delay: E.number,
  ignoreCase: E.bool,
  iconClassName: E.string,
  svgIcon: Rt,
  defaultItem: E.any,
  valueRender: E.func,
  valueMap: E.func,
  validationMessage: E.string,
  required: E.bool,
  id: E.string,
  ariaLabelledBy: E.string,
  ariaDescribedBy: E.string,
  ariaLabel: E.string,
  leftRightKeysNavigation: E.bool,
  title: E.string,
  groupField: E.string,
  list: E.any,
  skipDisabledItems: E.bool
};
const T = {
  delay: 500,
  tabIndex: 0,
  ignoreCase: !0,
  ...lt.defaultProps,
  required: !1,
  size: "medium",
  rounded: "medium",
  fillMode: "solid",
  groupMode: "modern"
};
Ke.displayName = "KendoReactDropDownList";
const wn = en();
Ke.displayName = "KendoReactDropDownList";
export {
  Ke as DropDownList,
  wn as DropDownListPropsContext,
  T as dropDownListDefaultProps
};
