/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use client";
import * as i from "react";
import { canUseDOM as ee, getActiveElement as Ht, useDir as Ft, setScrollbarWidth as Fe, cloneArray as Lt, getter as te, RowHeightService as Le } from "@progress/kendo-react-common";
import { getSelectionOptions as ne, populateClipboardData as Gt, ClipboardActionType as Re, getEditableOptions as zt, tableKeyboardNavigation as T, ClipboardService as Nt, TableKeyboardNavigationContext as Ot, editReducer as Bt, EDIT_ACTION as Ut, getDetailExpandableOptions as Vt, detailExpandReducer as Ge, getGroupExpandableOptions as Wt, groupExpandReducer as _t, DETAIL_EXPAND_ACTION as jt, getSelectedState as ze, getSelectedStateFromKeyDown as qt, closestTagName as Ne, getColumnIndex as Xt, getRowIndex as $t, updateLeft as Jt, updateRight as Yt } from "@progress/kendo-react-data-tools";
import { ColumnResize as Qt } from "./drag/ColumnResize.mjs";
import { CommonDragLogic as Zt } from "./drag/CommonDragLogic.mjs";
import { SAFARI_REGEX as pt } from "./constants/index.mjs";
import { getDefaultHeadContextMenuItems as en, getDefaultBodyContextMenuItems as tn, isRowReorderEnabled as nn, sanitizeColumns as rn, getDataAsArray as on, getFlatColumnsState as an, firefox as Oe, firefoxMaxHeight as Be } from "./utils/index.mjs";
import { VirtualScrollFixed as Ue } from "./VirtualScrollFixed.mjs";
import { VirtualScroll as dn } from "./VirtualScroll.mjs";
import { GridContextMenu as cn } from "./contextMenu/GridContextMenu.mjs";
import { GridContextMenuAnchorPart as Ve } from "./contextMenu/enums.mjs";
import { normalizeSortable as ln, firstLevelSortSeqMap as sn } from "./sortCommon.mjs";
const un = i.createContext(void 0), yn = (t) => {
  var Ae, He;
  const w = t.gridProps.isClient, [b, Ce] = i.useState({}), We = (e) => {
    e.event.preventDefault(), Ce({
      ...b,
      show: !0,
      offset: {
        left: e.event.pageX,
        top: e.event.pageY
      },
      dataItem: e.dataItem,
      field: e.field
    });
  }, ve = () => {
    Ce({});
  }, m = i.useMemo(() => t.columnsRef.find((e) => e.field === b.field), [t.columnsRef, b]), Ee = i.useMemo(() => {
    const e = t.gridProps.sortable && (m == null ? void 0 : m.sortable);
    return en({
      sortable: !!e,
      selectable: ne(t.gridProps.selectable).enabled,
      clipboard: !!t.gridProps.clipboard
    });
  }, [m, t.gridProps.sortable, t.gridProps.selectable, t.gridProps.clipboard]), we = i.useMemo(() => {
    const e = t.gridProps.sortable && (m == null ? void 0 : m.sortable);
    return tn({
      sortable: !!e,
      selectable: ne(t.gridProps.selectable).enabled,
      clipboard: !!t.gridProps.clipboard,
      rowReorderable: nn(t.gridProps.rowReorderable)
    });
  }, [m, t.gridProps.sortable, t.gridProps.selectable, t.gridProps.clipboard]), U = i.useMemo(() => {
    const e = (m == null ? void 0 : m.contextMenu) || t.gridProps.contextMenu, n = typeof e == "function" ? e(b) : e;
    if (n && b.offset) {
      const o = b.dataItem ? Ve.body : Ve.head, r = n[o], a = b.dataItem ? we : Ee;
      return r === !1 ? void 0 : r === !0 || r === void 0 ? a : r;
    }
  }, [t.gridProps.contextMenu, b, we, Ee, m]), _e = (e) => {
    var l, u, g, f, C, p, I, N, O;
    const n = e.event.item, o = {
      target: R.current,
      syntheticEvent: e.event.syntheticEvent,
      nativeEvent: e.event.nativeEvent,
      menuItem: n,
      ...e
    };
    t.gridProps.onContextMenuItemClick && s(t.gridProps.onContextMenuItemClick, o);
    const r = q(), a = {
      selectedField: t.gridProps.selectedField || "",
      componentId: t.id,
      dataItems: r,
      dataItem: e.dataItem,
      startRowIndex: -1,
      endRowIndex: -1,
      startColIndex: -1,
      endColIndex: -1,
      ctrlKey: !1,
      altKey: !1,
      metaKey: !1,
      shiftKey: !1,
      isDrag: !1,
      ...ne(t.gridProps.selectable),
      ...o
    }, d = r.findIndex((B) => B === e.dataItem);
    switch ((l = n.data) == null ? void 0 : l.action) {
      case "SortCommand":
        if (m) {
          const B = (u = n.name) == null ? void 0 : u.toLowerCase().includes("asc"), Tt = ((g = n.name) == null ? void 0 : g.toLowerCase().includes("desc")) ? "desc" : void 0, Mt = B ? "asc" : Tt, At = n.name ? Mt : void 0;
          ye(e.event.syntheticEvent, m, At);
        }
        break;
      case "SelectRowCommand":
        dt(a);
        break;
      case "SelectAllRowsCommand":
        it(a);
        break;
      case "ClearSelectionCommand":
        ct(a);
        break;
      case "ReorderRowCommand":
        z.current = e.dataItem, (f = n.name) != null && f.toLowerCase().includes("rowup") && d > 0 && A(e.event.syntheticEvent, d - 1, "before"), (C = n.name) != null && C.toLowerCase().includes("rowdown") && d < r.length - 1 && A(e.event.syntheticEvent, d + 1, "after"), (p = n.name) != null && p.toLowerCase().includes("rowtop") && A(e.event.syntheticEvent, 0, "before"), (I = n.name) != null && I.toLowerCase().includes("rowbottom") && A(e.event.syntheticEvent, r.length - 1, "after");
        break;
      case "CopySelectionCommand":
        j(
          Re.copy,
          e.event.nativeEvent,
          {
            copyHeaders: !((N = n.name) != null && N.toLowerCase().includes("noheaders"))
          },
          e.dataItem,
          e.field
        );
        break;
      case "PasteCommand":
        j(
          Re.paste,
          e.event.nativeEvent,
          {
            copyHeaders: !((O = n.name) != null && O.toLowerCase().includes("noheaders"))
          },
          e.dataItem,
          e.field
        );
        break;
    }
    ve();
  }, V = () => {
    const e = t.columnsRef.filter((n) => n.declarationIndex >= 0 && n.parentIndex === -1);
    return rn(e);
  }, je = (e, n, o) => {
    if (t.gridProps.onContextMenu && w) {
      const r = {
        target: R.current,
        syntheticEvent: e,
        nativeEvent: e.nativeEvent,
        dataItem: n,
        field: o
      };
      s(t.gridProps.onContextMenu, r);
    }
    t.gridProps.contextMenu && We({
      event: e,
      dataItem: n,
      field: o
    });
  }, qe = (e) => {
    if (e.target !== e.currentTarget)
      return;
    clearTimeout(Pe.current), c.current && (c.current.table = S.current);
    const n = e.currentTarget.scrollLeft, o = e.currentTarget.scrollTop, r = t.gridProps.scrollable === "virtual";
    t.gridProps.columnVirtualization && (!r || o === me.current) && (Pe.current = window.setTimeout(() => {
      ce();
    }, 0)), t.gridProps.scrollLeftRef && (t.gridProps.scrollLeftRef.current = n), G.current && G.current.setScrollLeft(n), L.current && L.current.setScrollLeft(n), c.current && o !== me.current && c.current.scrollHandler(e), t.gridProps.onScroll && w && s(t.gridProps.onScroll, {
      ...P(e)
    }), me.current = o;
  }, Xe = (e) => {
    T.onKeyDown(e, {
      navigatable: t.gridProps.navigatable || !1,
      contextStateRef: x,
      navigationStateRef: D,
      onNavigationAction: Je,
      columns: V()
    }), T.onGetSnapshotBeforeUpdate({
      document: v(),
      contextStateRef: x,
      navigationStateRef: D
    });
    const n = {
      dataItems: H(),
      mode: h.mode,
      cell: h.cell,
      componentId: t.id,
      selectedField: t.gridProps.selectedField,
      ...P(e)
    };
    t.gridProps.onKeyDown && w && s(t.gridProps.onKeyDown, n);
  }, $e = (e) => {
    T.onFocus(e, {
      navigatable: !!t.gridProps.navigatable,
      contextStateRef: x
    });
  }, Je = (e) => {
    if (e.action === "moveToNextPage" && st(e.event), e.action === "moveToPrevPage" && ut(e.event), e.focusElement && e.action === "reorderToRight") {
      const n = parseInt(e.focusElement.ariaColIndex, 10) - 1;
      n < t.columnsRef.length - 1 && ae(n, n + 1, e.event);
    }
    if (e.focusElement && e.action === "reorderToLeft") {
      const n = parseInt(e.focusElement.ariaColIndex, 10) - 1;
      n > 0 && ae(n, n - 1, e.event);
    }
    if (e.action === "select" && rt(e.event), t.gridProps.onNavigationAction && w) {
      const n = {
        focusElement: e.focusElement,
        ...P(e.event)
      };
      s(t.gridProps.onNavigationAction, n);
    }
  }, Ye = (e, n) => {
    t.gridProps.onRowClick && e.target.nodeName === "TD" && s(t.gridProps.onRowClick, {
      dataItem: n,
      ...P(e)
    });
  }, Qe = (e, n) => {
    t.gridProps.onRowDoubleClick && e.target.nodeName === "TD" && s(t.gridProps.onRowDoubleClick, {
      dataItem: n,
      ...P(e)
    });
  }, Ze = (e, n, o) => {
    if (Me.enabled && Me.mode === "incell" && t.gridProps.dataItemKey) {
      const r = Bt(t.gridProps.edit, {
        type: Ut.ENTER_FIELD_EDIT,
        payload: { id: n[t.gridProps.dataItemKey], field: o }
      });
      t.gridProps.onEditChange && s(t.gridProps.onEditChange, {
        edit: r,
        ...P(e)
      });
    }
  }, pe = (e, n) => {
    var r;
    if (Vt(t.detailExpandable).enabled) {
      const a = Ge((r = t.gridProps.detailExpand) != null ? r : {}, e);
      t.gridProps.onDetailExpandChange && s(t.gridProps.onDetailExpandChange, {
        ...P(n),
        detailExpand: a
      });
    }
  }, et = (e, n) => {
    var r;
    const o = Wt(
      typeof t.gridProps.groupable == "object" ? t.gridProps.groupable.expandable !== !1 : t.gridProps.groupable
    );
    if (o.enabled) {
      const a = _t((r = t.gridProps.groupExpand) != null ? r : [], e, o);
      t.gridProps.onGroupExpandChange && s(t.gridProps.onGroupExpandChange, {
        ...P(n),
        groupExpand: a
      });
    }
  }, ye = (e, n, o) => {
    const { allowUnsort: r, mode: a } = ln(
      t.gridProps.sortable || !1,
      n.sortable || !1
    ), d = (t.gridProps.sort || []).filter((g) => g.field === n.field)[0], l = o || sn[r][d && d.dir || ""], u = a === "single" ? [] : (t.gridProps.sort || []).filter((g) => g.field !== n.field);
    l !== "" && n.field && u.push({ field: n.field, dir: l }), xe(u, e);
  }, tt = (e) => {
    var n;
    if (e.field === t.gridProps.expandField || e._expand || t.gridProps.group && e.field === void 0) {
      if (t.gridProps.onExpandChange) {
        const o = t.gridProps.dataItemKey ? Ge((n = t.gridProps.detailExpand) != null ? n : {}, {
          type: jt.SET,
          id: e.dataItem[t.gridProps.dataItemKey],
          payload: e.value
        }) : t.gridProps.detailExpand;
        s(t.gridProps.onExpandChange, {
          ...P(e.syntheticEvent),
          expand: o,
          dataItem: e.dataItem,
          dataIndex: e.dataIndex,
          value: e.value
        });
      }
      return;
    }
    t.gridProps.onItemChange && s(t.gridProps.onItemChange, {
      ...P(e.syntheticEvent),
      dataItem: e.dataItem,
      dataIndex: e.dataIndex,
      field: e.field,
      value: e.value
    });
  }, nt = (e) => {
    var n;
    if (t.gridProps.onSelectionChange && h.enabled) {
      const { event: o, dataItem: r, dataIndex: a, columnIndex: d } = e, l = {
        ...P(o.syntheticEvent),
        dataItem: r,
        startColIndex: d,
        endColIndex: d,
        startRowIndex: a,
        endRowIndex: a,
        dataItems: H(),
        altKey: !1,
        ctrlKey: !1,
        shiftKey: !1,
        metaKey: !1,
        mode: h.mode,
        cell: h.cell,
        isDrag: !1,
        componentId: t.id,
        selectedField: t.gridProps.selectedField || ""
      };
      s(t.gridProps.onSelectionChange, {
        ...l,
        select: t.gridProps.dataItemKey ? ze({
          event: l,
          selectedState: (n = t.gridProps.select) != null ? n : {},
          dataItemKey: t.gridProps.dataItemKey
        }) : {}
      });
    }
  }, rt = (e) => {
    var g, f;
    if (t.gridProps.selectedField || !h.enabled || !t.gridProps.dataItemKey)
      return;
    const n = {
      dataItems: H(),
      mode: h.mode,
      cell: h.cell,
      componentId: t.id,
      selectedField: t.gridProps.selectedField,
      ...P(e)
    }, o = qt({
      event: n,
      selectedState: (g = t.gridProps.select) != null ? g : {},
      dataItemKey: t.gridProps.dataItemKey
    });
    if (o === t.gridProps.select)
      return;
    const r = e.target, a = Ne(r, "TD"), d = Ne(r, "TR"), l = Xt(a), u = $t(d);
    if (l !== void 0 && u !== void 0) {
      const C = (f = on(t.gridProps.data)) == null ? void 0 : f[u];
      t.gridProps.onSelectionChange && s(t.gridProps.onSelectionChange, {
        ...n,
        select: o,
        dataItem: C,
        startRowIndex: u,
        startColIndex: l,
        startDataItem: C,
        endDataItem: C,
        endRowIndex: u,
        endColIndex: l,
        ctrlKey: e.ctrlKey,
        altKey: e.altKey,
        metaKey: e.metaKey,
        shiftKey: e.shiftKey,
        isDrag: !1
      });
    }
  }, ot = (e) => {
    var n;
    if (t.gridProps.onHeaderSelectionChange && h.enabled) {
      const o = H();
      s(t.gridProps.onHeaderSelectionChange, {
        select: e.syntheticEvent.target.checked ? o.reduce((r, a) => (t.gridProps.dataItemKey && te(t.gridProps.dataItemKey)(a) !== void 0 && (r[te(t.gridProps.dataItemKey)(a)] = !0), r), {}) : {},
        field: e.field,
        nativeEvent: e.syntheticEvent && e.syntheticEvent.nativeEvent,
        syntheticEvent: e.syntheticEvent,
        target: R.current,
        dataItems: o,
        selectedField: (n = t.gridProps.selectedField) != null ? n : ""
      });
    }
  }, W = (e, n) => {
    t.gridProps.onSelectionChange && h.enabled && s(t.gridProps.onSelectionChange, {
      ...e,
      select: n
    });
  }, at = (e) => {
    var n;
    if (t.gridProps.onSelectionChange && h.enabled) {
      const o = q()[e.startRowIndex], r = q()[e.endRowIndex], a = {
        syntheticEvent: void 0,
        target: R.current,
        selectedField: t.gridProps.selectedField || "",
        componentId: t.id,
        dataItems: H(),
        dataItem: null,
        startDataItem: o,
        endDataItem: r,
        ...e
      }, d = ze({
        event: a,
        selectedState: (n = t.gridProps.select) != null ? n : {},
        // Thats kinda strange, even through the `dataItemKey` is required by the `getSelectedState`
        // it does work correctly even without it
        dataItemKey: t.gridProps.dataItemKey
      });
      W(a, d);
    }
  }, it = (e) => {
    if (t.gridProps.onSelectionChange && h.enabled) {
      const n = e.dataItems[0], o = e.dataItems[e.dataItems.length - 1], r = {}, a = {
        ...e,
        startDataItem: n,
        endDataItem: o,
        startRowIndex: 0,
        endRowIndex: e.dataItems.length - 1,
        startColIndex: 0,
        endColIndex: t.columnsRef.length - 1
      };
      e.dataItems.forEach((d) => {
        const u = te(t.gridProps.dataItemKey)(d);
        r[u] = e.cell ? [...Array(t.columnsRef.length).keys()] : !0;
      }), W(a, r);
    }
  }, dt = (e) => {
    if (t.gridProps.onSelectionChange && h.enabled) {
      const o = te(t.gridProps.dataItemKey)(e.dataItem), r = 0, a = t.columnsRef.length - 1, d = e.dataItems.findIndex(
        (C) => C[t.gridProps.dataItemKey] === e.dataItem[t.gridProps.dataItemKey]
      ), g = {
        ...e,
        startDataItem: d,
        endDataItem: d,
        startRowIndex: d,
        endRowIndex: d,
        startColIndex: r,
        endColIndex: a
      }, f = e.mode === "multiple" ? t.gridProps.select || {} : {};
      f[o] === !0 || Array.isArray(f[o]) && f[o].length === t.columnsRef.length ? delete f[o] : f[o] = e.cell ? [...Array(t.columnsRef.length).keys()] : !0, W(g, f);
    }
  }, ct = (e) => {
    t.gridProps.onSelectionChange && h.enabled && W(e, {});
  }, M = (e, n, o, r, a) => {
    const d = t.gridProps.onDataStateChange;
    if (e) {
      const l = { ...P(r), ...n, targetEvent: a };
      s(e, l);
    } else d && s(d, {
      ...P(r),
      targetEvent: a || {},
      dataState: {
        ...Rt(),
        ...o
      }
    });
  }, _ = (e, n, o) => {
    M(
      t.gridProps.onPageChange,
      { page: e },
      { skip: e.skip, take: e.take },
      n,
      o
    );
  }, lt = () => {
    let e = t.gridProps.total || 0;
    return Array.isArray(t.gridProps.data) ? e = e || t.gridProps.data.length : t.gridProps.data && (e = e || t.gridProps.data.total), e;
  }, st = (e) => {
    var a, d;
    const n = (d = (a = t.gridProps.take) != null ? a : t.gridProps.pageSize) != null ? d : 0, o = (t.gridProps.skip || 0) + n, r = lt();
    o < r && _({ skip: o, take: n }, e);
  }, ut = (e) => {
    var r, a;
    const n = (a = (r = t.gridProps.take) != null ? r : t.gridProps.pageSize) != null ? a : 0, o = (t.gridProps.skip || 0) - n;
    o >= 0 && _({ skip: o, take: n }, e);
  }, gt = (e) => {
    _({ skip: e.skip, take: e.take }, e.syntheticEvent, e.targetEvent);
  }, xe = (e, n) => {
    M(
      t.gridProps.onSortChange,
      { sort: e },
      { sort: e, ...t.gridProps.scrollable === "virtual" ? { skip: 0 } : {} },
      n
    );
  }, ft = (e, n) => {
    M(
      t.gridProps.onFilterChange,
      { filter: e },
      { filter: e || void 0, skip: 0 },
      n
    );
  }, mt = (e) => {
    const n = t.gridProps.searchFields || t.columnsRef.map((a) => a.field) || [], o = e.nativeEvent.target.value, r = {
      logic: "or",
      filters: n.filter((a) => a !== void 0).map((a) => {
        var d;
        return typeof a == "string" ? { field: a, value: o, operator: "contains" } : {
          value: o,
          operator: (d = a.operator) != null ? d : "contains",
          field: a.field,
          ignoreCase: a.ignoreCase
        };
      })
    };
    M(
      t.gridProps.onSearchChange,
      {
        search: r
      },
      {},
      e.syntheticEvent
    );
  }, re = (e, n) => {
    const o = n.nativeEvent ? n : { nativeEvent: n.nativeEvent || n.originalEvent };
    e.length === 0 && t.gridProps.navigatable && (ue.current = !0), M(
      t.gridProps.onGroupChange,
      { group: e },
      { group: e, skip: 0 },
      o
    );
  }, oe = (e) => {
    if (t.gridProps.onColumnsStateChange) {
      const n = {
        target: R.current,
        columnsState: e
      };
      s(t.gridProps.onColumnsStateChange, n);
    }
  }, ae = (e, n, o) => {
    const { columnsRef: r, columnsState: a } = t, d = r[e], l = an(a), u = d.depth, g = (I) => {
      do
        I++;
      while (I < r.length && r[I].depth > u);
      return I;
    }, f = r.splice(e, g(e) - e);
    r.splice(e < n ? g(n - f.length) : n, 0, ...f), r.filter((I) => I.declarationIndex >= 0).forEach((I, N) => {
      I.orderIndex = N;
      const O = l.find((B) => B.id === I.id);
      O && (O.orderIndex = N);
    });
    const C = r[e].locked && r[n].locked;
    Jt(t.columnsMapRef, r, C || Q.current), Yt(t.columnsMapRef, r, C || Q.current), se.current && (Q.current = !1, se.current = !1);
    const p = V();
    if (ce(), t.gridProps.onColumnReorder) {
      const I = {
        target: R.current,
        columns: p,
        columnId: d.id,
        nativeEvent: o
      };
      s(t.gridProps.onColumnReorder, I);
    }
    oe(a);
  }, A = (e, n, o) => {
    const r = typeof t.gridProps.rowReorderable == "object" ? t.gridProps.rowReorderable.enabled : t.gridProps.rowReorderable;
    if (o === "forbidden" || !r || !z.current)
      return;
    const { slicedData: a, dataRef: d } = t, l = (a || d)[n];
    t.gridProps.onRowReorder && s(t.gridProps.onRowReorder, {
      draggedDataItems: [z.current],
      droppedDataItem: l == null ? void 0 : l.dataItem,
      dropPosition: o,
      nativeEvent: e.originalEvent,
      dragEvent: e,
      target: R.current
    }), z.current = null;
  }, Pt = (e, n, o) => {
    if (t.gridProps.group === void 0)
      return;
    const r = t.gridProps.group.slice();
    r.splice(n, 0, ...r.splice(e, 1)), re(r, o);
  }, Se = (e, n, o) => {
    const r = t.columnsRef[e].field;
    if (!r)
      return;
    const a = (t.gridProps.group || []).slice();
    a.splice(n, 0, { field: r }), re(a, o);
  }, ht = (e, n) => {
    const o = y.current.getCurrentGroupsLength;
    Se(e, o, n);
  }, ie = () => {
    let e = 0;
    if (!E.current.colGroupMain)
      return;
    const n = E.current.colGroupMain.children;
    for (let o = 0; o < n.length; o++) {
      const r = n[o].width;
      if (!r) {
        e = 0;
        break;
      }
      e += parseFloat(r.toString());
    }
    e = Math.round(e), G.current && G.current.setWidth(e), L.current && L.current.setWidth(e), S.current && (S.current.style.width = e ? e + "px" : "");
  }, ke = () => {
    var e;
    t.gridProps.widthRef && (t.gridProps.widthRef.current = ((e = k.current) == null ? void 0 : e.offsetWidth) || 0);
  }, j = i.useCallback(
    (e, n, o, r, a) => {
      var g;
      if (!It() && !o || !e)
        return;
      const d = {
        type: e,
        nativeEvent: n,
        columns: t.columnsRef,
        dataItemKey: t.gridProps.dataItemKey || "",
        dataItem: r,
        field: a,
        ...typeof t.gridProps.clipboard != "boolean" ? t.gridProps.clipboard : {},
        ...o
      }, l = q(), u = Gt({
        event: d,
        data: l,
        selectedState: (g = t.gridProps.select) != null ? g : {},
        previousCopiedItems: Te.current
      });
      e !== Re.paste && (Te.current = u.copiedItems), t.gridProps.onClipboard && w && s(t.gridProps.onClipboard, {
        ...d,
        ...u
      });
    },
    [
      t.gridProps.select,
      t.gridProps.dataItemKey,
      t.gridProps.data,
      t.gridProps.clipboard,
      t.gridProps.onClipboard
    ]
  ), It = () => {
    var a, d, l;
    if (!ee)
      return !1;
    const e = Ht(v()), n = e ? e.matches(".k-table-td") ? e : (a = v()) == null ? void 0 : a.body : (d = v()) == null ? void 0 : d.body, o = n.closest(".k-grid-container"), r = n && ((l = k.current) == null ? void 0 : l.contains(n));
    return !!(n && r && o);
  }, bt = (e, n, o, r, a, d, l) => {
    ie(), Q.current = !0, se.current = !0, t.gridProps.onColumnResize && w && s(t.gridProps.onColumnResize, {
      columns: V(),
      nativeEvent: r,
      targetColumnId: l,
      index: e,
      newWidth: n,
      oldWidth: o,
      end: a,
      target: R.current
    }), a && oe(d);
  }, Rt = () => {
    var e;
    return {
      filter: t.gridProps.filter,
      sort: t.gridProps.sort,
      skip: t.gridProps.skip,
      take: (e = t.gridProps.take) != null ? e : t.gridProps.pageSize,
      group: t.gridProps.group
    };
  }, P = (e) => ({
    nativeEvent: e && e.nativeEvent,
    syntheticEvent: e,
    target: R.current
  }), Ct = (e) => ({
    ...e,
    nativeEvent: void 0,
    syntheticEvent: void 0,
    target: void 0,
    targetEvent: void 0,
    focusElement: void 0
  }), s = (e, n) => {
    if (t.gridProps.isClient) {
      e(n);
      return;
    }
    e(Ct(n));
  }, vt = () => {
    var e, n, o;
    if (F.current && ((e = F.current) == null ? void 0 : e.getElementsByClassName("k-grid-edit-row").length) > 0) {
      fe.current = !1, (n = document.activeElement) != null && n.closest(".k-grid-edit-row") ? ge.current = document.activeElement : ge.current = void 0;
      const r = Array.from((o = F.current) == null ? void 0 : o.getElementsByClassName("k-grid-edit-row"));
      r.length > Ie.current.length ? Y.current = r.filter(
        (a) => !Ie.current.includes(a)
      )[0] : r.length === 1 && (Y.current = r[0], fe.current = !0), Ie.current = r;
    }
  }, H = () => t.dataRef.filter((e) => e.rowType === "data").map((e) => e.dataItem), q = () => (t.slicedData || t.dataRef).filter((e) => e.rowType === "data").map((e) => e.dataItem), v = () => {
    var e;
    if (ee)
      return ((e = X()) == null ? void 0 : e.ownerDocument) || document;
  }, X = () => k.current, de = i.useCallback(
    (e) => {
      var r;
      if (!c.current || !((r = c.current) != null && r.container) || t.gridProps.scrollable === "none")
        return;
      K.current && K.current.disconnect();
      const { rowIndex: n } = e, o = X();
      if (t.gridProps.scrollable === "virtual")
        c.current.askedSkip = n, c.current.container.scroll(
          0,
          Math.round(c.current.askedSkip / c.current.total * c.current.container.scrollHeight)
        );
      else if (o) {
        const a = n < 1 ? o.querySelector("tbody > tr:nth-child(1)") : o.querySelector(`tbody > tr:nth-child(${n + 1})`);
        a && J.current && (J.current.scrollTop = a.offsetTop);
      }
    },
    [t.gridProps.scrollable]
  ), De = (e) => JSON.stringify(e.map((n) => ({ id: n.id, field: n.field, title: n.title, children: n.children }))), Et = () => De(Kt) === De(t.columnsRef), wt = () => {
    Et() || ce();
  }, yt = (e) => {
    var n, o;
    if (c.current) {
      if (c.current.fixedScroll = t.gridProps.fixedScroll || !1, c.current.PageChange = _, c.current.realSkip = t.gridProps.skip || 0, c.current.pageSize = (o = (n = t.gridProps.take) != null ? n : t.gridProps.pageSize) != null ? o : 0, c.current.scrollableVirtual = t.gridProps.scrollable === "virtual", c.current.total = e, c.current.propsSkip = (t.gridProps.skip || 0) + (t.gridProps.scrollable === "virtual" ? c.current.topCacheCount + (c.current.attendedSkip - (t.gridProps.skip || 0)) : 0), t.gridProps.rowHeight !== void 0 && t.gridProps.rowHeight > 0 && !Z) {
        const r = t.gridProps.rowHeight * e;
        c.current.containerHeight = Oe ? Math.min(Be, r) : r;
      } else
        c.current.containerHeight = 1533915;
      if (c.current.containerRef = J, c.current.tableBodyRef = F, c.current.table = S.current, c.current instanceof Ue) {
        const { rowHeight: r = 0, detail: a, expandField: d } = t.gridProps;
        let { detailRowHeight: l = 0 } = t.gridProps;
        l = a && d ? l : r, t.isAllData ? (c.current.total = t.dataRef.length, c.current.rowHeightService = new Le(
          t.dataRef.length,
          r,
          l,
          t.dataRef
        )) : c.current.rowHeightService = new Le(e, r, l);
        const u = c.current.rowHeightService.totalHeight();
        c.current.containerHeight = Oe ? Math.min(Be, u) : u;
      }
    }
  }, Ke = i.useCallback(
    (e) => {
      const n = { rowIndex: he.current };
      e.forEach((o) => {
        o.isIntersecting || de(n);
      });
    },
    [de]
  ), ce = () => {
    t.gridProps.forceUpdate && t.gridProps.forceUpdate();
  }, xt = (e) => e.left !== void 0 ? be !== "rtl" ? { left: e.left, right: e.right } : { left: e.right, right: e.left } : {}, R = i.useRef(null), c = i.useRef(void 0), E = i.useRef(void 0), y = i.useRef(void 0), x = i.useRef(void 0), D = i.useRef(void 0), $ = i.useRef(void 0), K = i.useRef(null), F = i.useRef(null), St = i.useRef(null), J = i.useRef(null), S = i.useRef(null), le = i.useRef(null), k = i.useRef(null), L = i.useRef(null), G = i.useRef(null), se = i.useRef(!1), ue = i.useRef(!1), Y = i.useRef(void 0), ge = i.useRef(void 0), fe = i.useRef(!1), Q = i.useRef(!0), me = i.useRef(0), Pe = i.useRef(void 0), he = i.useRef(void 0), Ie = i.useRef([]), Te = i.useRef([]), z = i.useRef(null), kt = i.useRef(null), Dt = i.useRef(null), be = Ft(k), Kt = i.useMemo(() => i.Children.toArray(t.gridProps.children), [t.gridProps.children]), Z = t.gridProps.groupable === !0 || typeof t.gridProps.groupable == "object" && t.gridProps.groupable.enabled !== !1, h = ne((Ae = t.gridProps.selectable) != null ? Ae : !!t.gridProps.selectedField), Me = zt((He = t.gridProps.editable) != null ? He : !!t.gridProps.editField);
  return i.useMemo(() => {
    T.onConstructor({
      navigatable: !!t.gridProps.navigatable,
      contextStateRef: x,
      navigationStateRef: D,
      idPrefix: t.id
    });
  }, []), i.useMemo(() => {
    var n;
    (n = c.current) == null || n.reset();
    const e = t.isFixedVirtualScroll ? Ue : dn;
    c.current = new e(Z || t.gridProps.rowHeight === void 0 || t.gridProps.rowHeight === 0);
  }, [
    t.gridProps.scrollable,
    t.gridProps.total,
    t.gridProps.filter,
    t.gridProps.group,
    Z,
    t.gridProps.sort,
    t.gridProps.rowHeight
  ]), i.useEffect(() => (t.gridProps.clipboard && ($.current = new Nt(j), $.current.addEventListeners(v())), () => {
    $.current && $.current.removeEventListeners(v());
  }), [t.gridProps.onClipboard, t.gridProps.clipboard, j, v]), i.useEffect(() => (t.gridProps.columnVirtualization && !window.navigator.userAgent.match(pt) && (le.current && (le.current.style.display = "block"), S.current && (S.current.style.display = "block")), ke(), ie(), Fe(), T.onComponentDidMount({
    scope: k.current || void 0,
    contextStateRef: x,
    navigationStateRef: D
  }), () => {
    clearTimeout(Pe.current);
  }), []), i.useEffect(() => {
    var e;
    ke(), ie(), Fe(), (e = c.current) != null && e.tableTransform && c.current.table && (c.current.table.style.transform = c.current.tableTransform, c.current.tableTransform = ""), vt(), T.onComponentDidUpdate({
      scope: k.current || void 0,
      contextStateRef: x,
      navigationStateRef: D,
      focusFirst: ue.current,
      newEditableRow: Y.current,
      singleEditRow: fe.current,
      lastActiveElement: ge.current,
      navigatable: t.gridProps.navigatable
    }), ue.current = !1, Y.current = void 0;
  }), i.useEffect(() => {
    if (ee) {
      const e = {
        rootMargin: "0px",
        threshold: 0.9
      };
      K.current = window.IntersectionObserver && new window.IntersectionObserver(Ke, e) || null;
    }
  }, [Ke]), i.useEffect(() => {
    var n;
    let e;
    return ee && window.ResizeObserver && (e = new window.ResizeObserver(wt), e.observe((n = v()) == null ? void 0 : n.body)), () => {
      e == null || e.disconnect();
    };
  }, []), i.useImperativeHandle(
    R,
    () => ({
      get element() {
        return X();
      },
      props: t.gridProps,
      get columns() {
        return V();
      },
      scrollIntoView: (e) => {
        var r;
        if (!((r = c.current) != null && r.container) || t.gridProps.scrollable === "none")
          return;
        const { rowIndex: n } = e;
        he.current = n;
        const o = X();
        if (K.current && o) {
          K.current.disconnect();
          const a = o.querySelector(`[absolute-row-index="${he.current}"]`);
          a ? K.current.observe(a) : de(e);
        }
      },
      fitColumns: (e) => {
        E.current.dblClickHandler(null, e);
      }
    })
  ), i.useImperativeHandle(t.gridRef, () => R.current), i.useMemo(() => {
    E.current = new Qt(bt);
  }, [t.gridProps.onColumnResize, t.columnsRef]), i.useMemo(() => {
    y.current = new Zt(ae, Pt, Se);
  }, [
    t.gridProps.onColumnReorder,
    t.gridProps.onGroupChange,
    t.gridProps.group,
    t.columnsRef,
    t.gridProps.groupable
  ]), E.current.resizable = t.gridProps.resizable || !1, E.current.columns = t.columnsRef, E.current.columnsState = Lt(t.columnsState), y.current.reorderable = t.gridProps.reorderable || !1, y.current.groupable = Z, y.current.columns = t.columnsRef, y.current.dir = be, yt(t.total), /* @__PURE__ */ i.createElement(
    un.Provider,
    {
      value: {
        isClient: w,
        rowReorder: A,
        activeDragRowDataItemRef: z,
        reorderRowDragTargetRef: kt,
        reorderRowDropTargetRef: Dt,
        dir: be,
        getCellPositionStyle: xt,
        dataItemKey: t.gridProps.dataItemKey,
        columnsState: t.columnsState,
        onColumnsStateChange: oe,
        groupChange: re,
        selectionRelease: at,
        pagerPageChange: gt,
        onContextMenu: je,
        rowClick: Ye,
        rowDblClick: Qe,
        cellClick: Ze,
        headerCellClick: ye,
        itemChange: tt,
        sortChange: xe,
        filterChange: ft,
        searchChange: mt,
        onHeaderSelectionChange: ot,
        columnGroupChange: ht,
        onKeyDown: Xe,
        onFocus: $e,
        scrollHandler: qe,
        selectionChange: nt,
        dispatchDetailExpand: pe,
        dispatchGroupExpand: et,
        columnResizeRef: E,
        dragLogicRef: y,
        navigationStateRef: D,
        tableElementRef: S,
        tableBodyElementRef: F,
        headerElementRef: St,
        containerElementRef: J,
        headTableElementRef: le,
        elementRef: k,
        footerRef: L,
        headerRef: G,
        vsRef: c
      }
    },
    /* @__PURE__ */ i.createElement(Ot.Provider, { value: x.current }, t.children),
    /* @__PURE__ */ i.createElement(
      cn,
      {
        show: b.show && (U == null ? void 0 : U.length),
        dataItem: b.dataItem,
        field: b.field,
        items: U,
        offset: b.offset,
        onClose: ve,
        onSelect: _e
      }
    )
  );
};
export {
  yn as GridClientWrapper,
  un as GridContext
};
