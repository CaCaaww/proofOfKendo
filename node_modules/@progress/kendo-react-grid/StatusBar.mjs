/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as c from "react";
import { validatePackage as k, WatermarkOverlay as v, getter as d } from "@progress/kendo-react-common";
import { packageMetadata as S } from "./package-metadata.mjs";
const x = (o) => {
  const { data: n = [] } = o, r = !k(S, { component: "StatusBar" });
  return /* @__PURE__ */ c.createElement("div", { className: "k-selection-aggregates k-grid-selection-aggregates" }, n.map((a, i) => /* @__PURE__ */ c.createElement("div", { key: i }, /* @__PURE__ */ c.createElement("span", { className: "k-selection-aggregates-item-text" }, a.type, ": "), /* @__PURE__ */ c.createElement("span", { className: "k-selection-aggregates-item-value" }, a.formattedValue))), r && /* @__PURE__ */ c.createElement(v, null));
};
x.displayName = "KendoReactGridStatusBar";
const D = (o) => {
  var r;
  const n = o.slice();
  for (let a = 0; a < n.length; a++)
    for (; n[a] && ((r = n[a].children) != null && r.length); )
      n.splice(a, 1, ...n[a].children);
  return n;
}, N = (o) => {
  const { dataItems: n, target: r } = o, i = D(r.columns).map((e) => e.field).filter((e) => e && typeof e == "string").map(
    (e) => d(e)
  ), b = "selectedField" in o ? d(o.selectedField) : (e) => o.select[d(o.dataItemKey)(e)], t = { dates: [], numbers: [], booleans: [], others: [] }, y = (e) => {
    typeof e == "number" ? t.numbers.push(e) : typeof e == "boolean" ? t.booleans.push(e) : e instanceof Date ? t.dates.push(e) : t.others.push(e);
  };
  n.forEach((e) => {
    const s = b(e);
    s && s.forEach((l) => {
      y(i[l](e));
    });
  });
  const g = t.dates.map((e) => e.getTime()), u = t.booleans.filter((e) => e).length, h = t.booleans.filter((e) => !e).length, m = t.numbers.length ? t.numbers.reduce((e, s) => e += s, 0) : void 0, f = {
    sum: m,
    average: typeof m == "number" ? m / t.numbers.length : void 0,
    min: t.numbers.length ? Math.min(...t.numbers) : void 0,
    max: t.numbers.length ? Math.max(...t.numbers) : void 0,
    count: t.numbers.length + t.booleans.length + t.dates.length + t.others.length,
    isTrue: u > 0 ? u : void 0,
    isFalse: h > 0 ? h : void 0,
    earliest: t.dates.length ? new Date(Math.min(...g)) : void 0,
    latest: t.dates.length ? new Date(Math.max(...g)) : void 0
  }, E = (e, s) => (s === "sum" || s === "average") && typeof e == "number" ? e.toFixed(2) : (s === "earliest" || s === "latest") && e instanceof Date ? e.toLocaleDateString() : String(e), p = [];
  return Object.keys(f).forEach((e) => {
    const s = e, l = f[s];
    l !== void 0 && p.push({ type: s, value: l, formattedValue: E(l, s) });
  }), p;
};
export {
  x as StatusBar,
  N as getStatusData,
  D as leafColumns
};
