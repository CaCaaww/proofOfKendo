/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import { getFlatColumnsState as u } from "../utils/index.mjs";
const m = 1, w = 20;
class E {
  constructor(p) {
    this.columns = [], this.columnsState = [], this.resizable = !1, this.isRtl = !1, this.setIsRtl = (c) => {
      this.isRtl = c;
    }, this.initWidths = () => {
      var r;
      const c = ((r = this.colGroupMain) == null ? void 0 : r.children) || [], l = u(this.columnsState), n = this.columns.filter((s) => {
        var o;
        return !((o = s.children) != null && o.length);
      });
      for (let s = 0; s < c.length; s++) {
        const o = c[s];
        let t = "";
        const i = l.find((h) => h.id === n[s].id);
        i && (t = i.width || ""), o.width = t, this.colGroupHeader && (this.colGroupHeader.children[s].width = t), this.colGroupFooter && (this.colGroupFooter.children[s].width = t);
      }
    }, this.dragHandler = (c, l, n, r) => {
      const s = c.originalEvent;
      r || (s.preventDefault(), s.stopPropagation(), s.stopImmediatePropagation());
      const o = n.closest("th");
      if (!o || !o)
        return;
      const t = o.clientWidth;
      let i = t;
      if (this.isRtl ? i += n.getBoundingClientRect().right - n.offsetWidth / 2 - c.clientX : i += c.clientX - n.getBoundingClientRect().left - n.offsetWidth / 2, !r && Math.abs(i - t) < 1)
        return;
      this.fixateInitialWidths(o.parentElement.clientWidth), this.setWidths(l, Math.floor(i) / t);
      const h = this.columns.filter((e) => !e.children.length).findIndex((e) => e.id === l.id);
      this.onResize(h, t, i, s, r, this.columnsState, l.id);
    }, this.dblClickHandler = (c, l) => {
      const n = this.columns.filter((d) => l.indexOf(d.id) > -1), r = u(this.columnsState);
      if (!this.colGroupMain || !n.length)
        return;
      const s = {}, o = n;
      for (; o.length > 0; ) {
        const d = o.pop();
        if (!d)
          break;
        d.children.length ? o.push(...d.children) : s[d.id] = d;
      }
      const t = this.columns.filter((d) => !d.children.length), i = [];
      t.forEach((d, f) => {
        s[d.id] && i.push(f);
      });
      const h = [this.colGroupMain.parentElement], e = [this.colGroupMain];
      this.colGroupHeader && (h.push(this.colGroupHeader.parentElement), e.push(this.colGroupHeader)), this.colGroupFooter && (h.push(this.colGroupFooter.parentElement), e.push(this.colGroupFooter)), h.forEach((d) => d.classList.add("k-autofitting"));
      const a = [];
      e.forEach((d) => {
        i.forEach((f) => {
          d.children[f] && (d.children[f].width = "", a[f] = Math.max(
            a[f] || 0,
            d.children[f].offsetWidth + m
          ));
        });
      }), e.forEach((d) => {
        i.forEach((f) => {
          if (d.children[f]) {
            d.children[f].width = a[f] + "px";
            const g = r.find((G) => G.id === t[f].id);
            g && (g.width = a[f]);
          }
        });
      }), h.forEach((d) => d.classList.remove("k-autofitting")), this.onResize(i[0], 0, 0, c, !0, this.columnsState, l[0]);
    }, this.updateColElements = (c) => {
      const l = this.columns.filter((r) => !r.hidden && !r.children.length);
      let n = 1e-10;
      for (let r = 0; r < c.length; r++) {
        const s = c[r], o = l.findIndex((a) => a.id === s.id), t = parseFloat((s.width || 0).toString()), i = Math.floor(t);
        n += t - i;
        const h = i + Math.floor(n);
        n -= Math.floor(n);
        const e = l.find((a) => a.id === s.id);
        if (!e)
          return;
        if (this.colGroupMain && this.colGroupMain.children[o]) {
          const a = parseInt(this.colGroupMain.children[o].width, 10);
          this.colGroupMain.children[o].width = h + "px", this.updateNextLockedCol(this.colGroupMain.parentElement, e, a - h);
        }
        if (this.colGroupHeader && this.colGroupHeader.children[o]) {
          const a = parseInt(this.colGroupHeader.children[o].width, 10);
          this.colGroupHeader.children[o].width = h + "px", this.updateNextLockedCol(this.colGroupHeader.parentElement, e, a - h);
        }
        if (this.colGroupFooter && this.colGroupFooter.children[o]) {
          const a = parseInt(this.colGroupFooter.children[o].width, 10);
          this.colGroupFooter.children[o].width = h + "px", this.updateNextLockedCol(this.colGroupFooter.parentElement, e, a - h);
        }
      }
    }, this.onResize = p;
  }
  fixateInitialWidths(p) {
    var o;
    let c = 0;
    const l = ((o = this.colGroupMain) == null ? void 0 : o.children) || [];
    for (let t = 0; t < l.length; t++)
      l[t].width ? p -= parseFloat(l[t].width) : c++;
    if (c === 0)
      return;
    const n = Math.floor(p / c), r = u(this.columnsState), s = this.columns.filter((t) => !t.children.length);
    for (let t = 0; t < l.length; t++) {
      const i = l[t];
      if (!i.width) {
        i.width = n;
        const h = r.find((e) => e.id === s[t].id);
        h && (h.width = n.toString()), this.colGroupHeader && (this.colGroupHeader.children[t].width = n), this.colGroupFooter && (this.colGroupFooter.children[t].width = n);
      }
    }
  }
  setWidths(p, c) {
    const l = u(this.columnsState), n = this.columns.findIndex((t) => t.id === p.id), r = [];
    let s = p.children.filter((t) => !t.hidden).length;
    for (let t = n + 1; t < this.columns.length && !(s <= 0); t++) {
      const i = this.columns[t];
      i.children.length ? s += i.children.filter((h) => !h.hidden).length : r.push(i), s--;
    }
    r.length === 0 && r.push(p);
    const o = [];
    r.forEach((t) => {
      const i = l.find((h) => h.id === t.id);
      if (i) {
        let h = i.width ? parseFloat(i.width.toString()) * c : 0;
        const e = t.minResizableWidth === void 0 ? 10 : t.minResizableWidth;
        h < e && (h = e), i.width = h, o.push(i);
      }
    }), this.updateColElements(o);
  }
  updateNextLockedCol(p, c, l) {
    const n = c.index, r = this.colGroupMain.parentElement.closest(".k-grid"), s = r == null ? void 0 : r.clientWidth, o = this.columns.filter((t) => t.locked).map((t) => parseInt(t.width + "", 10)).reduce((t, i) => t + i, 0);
    !c.locked || s <= o + w || this.columns.forEach((t) => {
      if (t != null && t.locked && l) {
        const i = p == null ? void 0 : p.querySelectorAll('[aria-colindex="' + t.ariaColumnIndex + '"]');
        i == null || i.forEach((h) => {
          const e = h.style;
          this.isRtl ? (t.index > n && e && e.right && (e.right = parseInt(e.right, 10) - l + "px"), t.index < n && e && e.left && (e.left = parseInt(e.left, 10) - l + "px")) : (t.index > n && e && e.left && (e.left = parseInt(e.left, 10) - l + "px"), t.index < n && e && e.right && (e.right = parseInt(e.right, 10) - l + "px"));
        });
      }
    });
  }
}
export {
  E as ColumnResize
};
