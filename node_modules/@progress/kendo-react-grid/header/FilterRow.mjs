/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as i from "react";
import { GridFilterCell as L } from "../cells/GridFilterCell.mjs";
import { getFilterType as R, operatorMap as b, booleanFilterValues as w } from "../filterCommon.mjs";
import { tableKeyboardNavigationTools as P, HeaderTdElement as z } from "@progress/kendo-react-data-tools";
import { filterAriaLabel as u, messages as N } from "../messages/index.mjs";
import { classNames as A } from "@progress/kendo-react-common";
import { clientColumn as G, isClientReference as F, resolveCells as S } from "../utils/index.mjs";
import { GridFilterCellContainer as E } from "./client/GridFilterCellContainer.mjs";
import { GridFilterCellElementContainer as $ } from "./client/GridFilterCellElementContainer.mjs";
const O = "k-table-row k-filter-row", q = (t) => {
  const x = (e, r) => {
    let l = `${r ? "k-grid-header-sticky" : ""}`;
    return t.sort && t.sort.filter((n) => n.field === e).length > 0 && (l += " k-sorted"), l;
  }, T = t.filter && t.filter.filters || [], h = (e) => {
    if (e === void 0)
      return;
    const r = T.filter(
      (l) => l.field === e
    );
    return r.length ? r[0] : void 0;
  };
  let k = 0, C = -1;
  const y = t.columns.filter((e) => e.children.length === 0).map((e) => {
    const r = R(e.filter), l = h(e.field), n = `${e.field} ${t.localization.toLanguageString(
      u,
      N[u]
    )}`;
    let s = l && l.value;
    s === void 0 && (s = r === "text" ? "" : null);
    const d = e.filterable && {
      field: e.field,
      title: e.filterTitle,
      value: s,
      operator: l && l.operator,
      operators: b(t.filterOperators[r] || [], t.localization),
      booleanValues: b(w, t.localization),
      filterType: r,
      ariaLabel: e.columnType === "reorder" ? "" : n,
      size: t.size
    }, f = e.declarationIndex >= 0 ? ++C : --k, a = {
      columnId: P.getFilterColumnId(e.id),
      navigatable: e.navigatable || t.navigatable,
      className: A("k-table-td", x(e.field, e.locked) || void 0),
      role: "gridcell",
      ariaLabel: e.columnType === "reorder" ? void 0 : n,
      ariaColumnIndex: e.ariaColumnIndex
    }, g = G(e), v = {
      column: g,
      filter: t.filter,
      field: e.field,
      tdProps: a,
      thProps: a,
      render: t.cellRender
    };
    let c = null;
    if (d && e.columnType !== "reorder") {
      const o = e.filterCell ? e.filterCell : L;
      c = /* @__PURE__ */ i.createElement(E, { ...v, isClient: F(o) }, /* @__PURE__ */ i.createElement(o, { ...d }));
    }
    const m = S(t.cells, e.cells);
    if (m && m.filterCell) {
      const o = m.filterCell, I = F(o);
      return /* @__PURE__ */ i.createElement(
        E,
        {
          key: f,
          ...v,
          isClient: I,
          isCustom: !0
        },
        /* @__PURE__ */ i.createElement(o, { key: f, ...d, tdProps: a, thProps: a, index: C }, c)
      );
    }
    return /* @__PURE__ */ i.createElement($, { key: f, column: g }, /* @__PURE__ */ i.createElement(z, { ...a }, c));
  });
  return /* @__PURE__ */ i.createElement("tr", { className: O, "aria-rowindex": t.ariaRowIndex, role: "row" }, y);
};
export {
  O as FILTER_ROW_CLASS,
  q as FilterRow
};
