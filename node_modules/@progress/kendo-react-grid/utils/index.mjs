/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as w from "react";
import { gridDefaultProps as b } from "../GridColumn.mjs";
import { getter as v } from "@progress/kendo-data-query";
import { findGroupExpand as M, updateLeft as A, updateRight as D, tableKeyboardNavigationTools as E } from "@progress/kendo-react-data-tools";
import { ServerFragment as m } from "./_serverModule.mjs";
import { ClientFragment as T } from "./_clientModule.mjs";
import { GridContextMenuItemNames as g } from "../contextMenu/enums.mjs";
import { canUseDOM as B } from "@progress/kendo-react-common";
function u(e, t) {
  const r = (e != null ? e : "").split(".");
  let i = t;
  return r.forEach((o) => {
    i = i ? i[o] : void 0;
  }), i;
}
function F(e, t, r, i, o, d, n, a, l, f, c = 0, h) {
  var C;
  let x = c;
  for (let s = 0; s < t.length; s++) {
    let S;
    if (!o || t[s].value === void 0 || t[s].items === void 0) {
      e[e.length] = {
        dataIndex: i.index,
        dataItem: t[s],
        rowType: "data",
        level: c,
        group: h,
        // This is related to detail-row expansion
        expanded: (C = d ? u(d, t[s]) : f && !!(n != null && n[v(f)(t[s])])) != null ? C : !1
      }, i.index++;
      continue;
    } else {
      let y;
      h != null && h.parents ? y = [{ field: h.field, value: h.value }, ...h.parents] : h ? y = [h] : y = [], S = {
        field: t[s].field,
        value: t[s].value,
        parents: y
      };
    }
    x = Math.max(x, c + 1);
    let I = !1;
    if (d)
      I = u(d, t[s]) !== !1;
    else {
      const y = M(a || [], S);
      y ? I = y.expanded !== !1 : I = l !== !1;
    }
    e[e.length] = {
      dataIndex: -1,
      dataItem: t[s],
      level: c,
      group: S,
      rowType: "groupHeader",
      expanded: I
    }, I && (S.expanded = I, x = Math.max(
      F(
        e,
        t[s].items,
        r,
        i,
        o,
        d,
        n,
        a,
        l,
        f,
        c + 1,
        S
      ),
      x
    )), (r === "always" || I && r === "visible") && (e[e.length] = {
      dataIndex: -1,
      dataItem: t[s],
      rowType: "groupFooter",
      level: c,
      expanded: I
    });
  }
  return x;
}
const K = (e, t) => typeof e.colSpan == "function" ? e.colSpan({ dataItem: t, column: e }) : e.colSpan || 1;
function Q(e, t) {
  const r = [[]];
  let i = 0;
  for (let n = e.length - 1; n >= 0; n--)
    i = Math.max(i, e[n].depth), e[n].headerColSpan = e[n].headerColSpan || 1, e[n].children.length > 0 && (e[n].headerColSpan = e[n].children.reduce(
      (a, l) => l.hidden ? a : a + l.headerColSpan,
      0
    ));
  const o = [];
  let d = 1;
  return e.forEach((n, a) => {
    r[n.depth] = r[n.depth] || [];
    let l = !1;
    r[n.depth].length === 0 && (d <= 1 ? d = 1 + (n.children.length > 0 ? 0 : i - n.depth) : (d--, l = !0)), n.rowSpan = 1 + (n.children.length > 0 ? 0 : i - n.depth), n.kFirst = l, n.index = r[n.depth].length, r[n.depth].push(a), n.ariaColumnIndex = o[n.depth] ? o[n.depth] + 1 : 1;
    for (let f = n.depth; f < n.depth + n.rowSpan; f++)
      o[f] = (o[f] || 0) + n.headerColSpan;
  }), A(r, e, t), D(r, e, t), r;
}
function j(e, t, r, i = 0, o = !1) {
  const d = [];
  if (!e)
    return [];
  e && e.length === void 0 && (e = [e]), e.forEach((a, l) => {
    a = a.props ? a.props : a;
    const f = a.id ? a.id : E.generateNavigatableId(`${r.prevId++}`, r.idPrefix, "column"), c = B && a.media && window.matchMedia ? !window.matchMedia(a.media).matches : !1, h = o || c || a.hidden, x = t == null ? void 0 : t.find((s) => s.id === f), C = j(a.children, (x == null ? void 0 : x.children) || [], r, i + 1, h);
    d.push(
      Object.assign(
        { depth: i },
        b,
        C.length ? { cell: () => null, filterCell: () => null } : {},
        a,
        {
          id: f,
          declarationIndex: d.length,
          children: C,
          headerColSpan: 0,
          rowSpan: 0,
          columnType: a.columnType || "data",
          colSpan: a.colSpan || 1,
          isAccessible: !0,
          hidden: h,
          left: null,
          right: null,
          rowSpannable: a.rowSpannable
        },
        x ? { width: x.width, orderIndex: x.orderIndex } : {}
      )
    );
  });
  const n = (a, l) => a.orderIndex === l.orderIndex ? a.declarationIndex - l.declarationIndex : (a.orderIndex || 0) - (l.orderIndex || 0);
  if (d.sort(n), i === 0) {
    const a = [], l = (f, c) => f.forEach((h) => {
      h.parentIndex = c, l(h.children, a.push(h) - 1);
    });
    return l(d, -1), a;
  }
  return d;
}
const H = (e) => Array.isArray(e) ? e : e ? e.data : [];
function X(e, t, r, i) {
  const o = H(e), d = [];
  if (o.length > 0) {
    let n = o[0];
    if (t)
      for (let l = 0; l < t.length; l++)
        n = n.items && n.items[0];
    Object.getOwnPropertyNames(n).forEach((l) => {
      l !== r.column && d.push(
        Object.assign(
          {
            id: E.generateNavigatableId(`${i.prevId++}`, i.idPrefix, "column"),
            declarationIndex: -1,
            parentIndex: -1,
            depth: 0,
            colSpan: 0,
            headerColSpan: 0,
            rowSpan: 0,
            index: 0,
            columnType: "data",
            left: 0,
            right: 0,
            rightBorder: !1,
            children: [],
            ariaColumnIndex: 0,
            isAccessible: !0
          },
          b,
          { field: l }
        )
      );
    });
  }
  return d;
}
const O = (e, t) => {
  let r = e[t.parentIndex];
  for (; r; ) {
    if (r.footerCell)
      return !0;
    r = e[r.parentIndex];
  }
  return !1;
}, Y = (e) => e.filter((t) => O(e, t) ? !1 : !!t.footerCell || !(t.children && t.children.length > 0)), Z = (e) => e.width !== void 0 ? Math.floor(parseFloat(e.width.toString())) + "px" : void 0, _ = (e, t) => t && t.filter((r) => r.field === e).length > 0, R = (e) => (e.sort((t, r) => t.declarationIndex - r.declarationIndex), e.map((t) => {
  const { declarationIndex: r, parentIndex: i, depth: o, headerColSpan: d, rowSpan: n, index: a, kFirst: l, children: f, ...c } = t;
  return f.length ? {
    children: R(f),
    ...c
  } : c;
})), N = (e) => {
  const { filterCell: t, headerCell: r, footerCell: i, cells: o, cell: d, rowSpannable: n, ...a } = e;
  return e.children.length ? {
    ...a,
    children: e.children.map(N)
  } : a;
}, k = (e) => ({
  id: e.id,
  field: e.field,
  title: e.title,
  width: e.width,
  hidden: !1,
  children: e.children ? p(e.children) : null
}), p = (e) => e.map(k), G = (e) => {
  const t = [], r = (i) => i == null ? void 0 : i.forEach((o) => {
    t.push(o), r(o.children);
  });
  return r(e), t;
}, P = typeof window != "undefined" && /Firefox/.test(window.navigator.userAgent), ee = 17895697, te = (e) => {
  let t = [];
  return e.sortable && (t = t.concat([g.sortAsc, g.sortDesc])), t;
}, ne = (e) => {
  let t = [];
  return e.clipboard && (t = t.concat([
    g.copySelection,
    g.copySelectionNoHeaders,
    g.paste
  ])), e.editable && (t.length && (t = t.concat([g.separator])), t = t.concat([
    g.create,
    g.edit,
    g.delete
  ])), e.selectable && (t.length && (t = t.concat([g.separator])), t = t.concat([g.select])), e.rowReorderable && (t.length && (t = t.concat([g.separator])), t = t.concat([g.reorderRow])), t;
}, re = (e, t) => {
  if (!(!e && !t))
    return t ? e ? {
      ...e,
      ...t,
      select: {
        ...e.select || {},
        ...t.select || {}
      },
      hierarchy: {
        ...e.hierarchy || {},
        ...t.hierarchy || {}
      },
      group: {
        ...e.group || {},
        ...t.group || {}
      },
      edit: {
        ...e.edit || {},
        ...t.edit || {}
      }
    } : t : e;
}, ae = (e) => {
  var r;
  return typeof e == "object" ? (r = e.enabled) != null ? r : !0 : e != null ? e : !1;
}, ie = () => m === T, de = (e) => !!(e && e.$$typeof === Symbol.for("react.client.reference")), le = (e) => ({
  id: e.id,
  ariaColumnIndex: e.ariaColumnIndex,
  isSelected: e.isSelected,
  isInEdit: e.isInEdit,
  isSorted: e.isSorted,
  isAlt: e.isAlt,
  expanded: e.expanded,
  className: e.className,
  style: e.style,
  field: e.field,
  dataItem: e.dataItem,
  format: e.format,
  colSpan: e.colSpan,
  dataIndex: e.dataIndex,
  columnIndex: e.columnIndex,
  columnsCount: e.columnsCount,
  rowType: e.rowType,
  level: e.level,
  editor: e.editor,
  render: e.render,
  locked: e.locked,
  isRtl: e.isRtl,
  rowDataIndex: e.rowDataIndex,
  columnPosition: e.columnPosition,
  group: e.group
}), oe = (e) => {
  var i, o;
  const t = typeof e == "object" ? (i = e.enabled) != null ? i : !0 : e != null ? e : !1, r = typeof e == "object" ? (o = e.valueGetter) != null ? o : (d, n) => v(n)(d) : (d, n) => v(n)(d);
  return { enabled: t, valueGetter: r };
}, $ = (e) => {
  var t;
  return w.isValidElement(e) ? e : (t = w.Children.toArray(e)) == null ? void 0 : t[0];
}, fe = (e, t) => {
  const r = $(e);
  return r ? w.cloneElement(r, t) : null;
};
export {
  X as autoGenerateColumns,
  N as clientColumn,
  fe as cloneReactElement,
  P as firefox,
  ee as firefoxMaxHeight,
  F as flatData,
  Y as footerColumns,
  le as getClientCellProps,
  K as getColSpan,
  k as getColumnState,
  Z as getColumnWidth,
  p as getColumnsState,
  H as getDataAsArray,
  ne as getDefaultBodyContextMenuItems,
  te as getDefaultHeadContextMenuItems,
  G as getFlatColumnsState,
  u as getNestedValue,
  $ as getReactElement,
  oe as getRowSpanOptions,
  ie as isClient,
  de as isClientReference,
  ae as isRowReorderEnabled,
  _ as isSorted,
  Q as mapColumns,
  j as readColumns,
  re as resolveCells,
  R as sanitizeColumns
};
