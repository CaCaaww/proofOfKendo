/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const oe=require("react"),G=require("prop-types"),re=require("./package-metadata.js"),C=require("@progress/kendo-react-common"),J=require("./TaskBoardColumnBase.js"),ce=require("./TaskBoardCardBase.js"),p=require("./constants.js"),_=require("./utils.js"),q=require("./card/Card.js"),Q=require("./column/Column.js");function le(o){const B=Object.create(null,{[Symbol.toStringTag]:{value:"Module"}});if(o){for(const D in o)if(D!=="default"){const i=Object.getOwnPropertyDescriptor(o,D);Object.defineProperty(B,D,i.get?i:{enumerable:!0,get:()=>o[D]})}}return B.default=o,Object.freeze(B)}const t=le(oe),M=t.forwardRef((o,B)=>{const D=!C.validatePackage(re.packageMetadata,{component:"TaskBoard"}),{columnData:i=[],className:V,style:Z,id:$,taskData:d=[],onChange:u}=o,L=t.useRef(null),j=t.useRef(null);t.useImperativeHandle(L,()=>({props:o})),t.useImperativeHandle(B,()=>L.current);const ee=t.Children.toArray(o.children).filter(e=>e&&e.type&&e.type.displayName==="KendoReactTaskBoardToolbar"),U=t.useRef(null),g=t.useRef(null),S=t.useRef(null),[b,K]=t.useState(null),[x,w]=t.useState(null),[I,N]=t.useState({top:0,left:0}),[te,X]=t.useState(),P=t.useRef(null),Y=t.useRef(null),A=t.useMemo(()=>{const e={};return(b||d).forEach(a=>{const n=a.status;e[n]||(e[n]=[]),e[n].push(a)}),e},[d,b]),ne=t.useCallback(e=>{const a=e.originalEvent.target;if(a.closest("button,input,.k-link,.k-taskboard-preview-pane"))return;const n=_.closestTaskBoardElement(a),s=j.current;if(n&&s){const c=n.type===p.TASKBOARD_COLUMN;if(c&&!a.closest(".k-taskboard-column-header"))return;const h=n.element.getBoundingClientRect(),y=s.getBoundingClientRect();S.current={x:e.clientX-h.left+y.left,y:e.clientY-h.top+y.top};const m=c?i:d,O=c?w:K,f=m.findIndex(v=>String(v.id)===n.id),T=m[f];if(f===-1||T.edit)return;const l=C.clone(T);l.isPlaceholder=!0;const R=[...m];R[f]=l,g.current={...n,index:f,item:T,width:h.width,height:h.height},X(f),N({top:e.clientY-S.current.y,left:e.clientX-S.current.x}),O(R)}},[i,d]),ae=t.useCallback(e=>{const a=g.current,n=P.current&&P.current.element||Y.current;if(a&&n){N({top:e.clientY-S.current.y,left:e.clientX-S.current.x}),n.style.visibility="hidden";const s=document.elementFromPoint(e.clientX,e.clientY);if(n.style.visibility="",s&&s.getAttribute(p.TASKBOARD_PLACEHOLDER))return;const c=s&&_.closestTaskBoardElement(s);if(c){let k;const h=c.type===a.type,y=a.type===p.TASKBOARD_COLUMN,m=(y?x:b)||[],O=y?w:K;if(y||h){if(k=_.findIndexes(a.id,c.id,m),k){const f=m[k.dragIndex],T=m[k.dropIndex],l=C.clone(f);y||(l.status=T.status);const R=[...m];R.splice(k.dragIndex,1),R.splice(k.dropIndex,0,l),a.index=k.dropIndex,O(R)}}else{const f=m.findIndex(l=>String(l.id)===a.id),T=i.findIndex(l=>String(l.id)===c.id);if(f!==-1&&T!==-1){const l=m[f],v=i[T].status;if(A[v])return;l.status=v;const E=[...m];E.splice(f,1),E.push(l),a.index=E.length-1,O(E)}}}}},[x,b,i,A]),se=t.useCallback(()=>{const e=g.current;if(u&&e){const n=(e.type===p.TASKBOARD_COLUMN?x:b)||[],s=n[e.index];delete s.isPlaceholder;const c={data:n,type:e.type,previousItem:{...e.item,index:te},item:{...s,index:e.index}};u.call(void 0,c)}g.current=null,S.current=null,K(null),w(null),N({top:0,left:0}),X(void 0)},[x,b,u]);C.useDraggable(U,{onDragStart:ne,onDrag:ae,onDragEnd:se});const r=g.current,z=t.useCallback(e=>{const n={data:[...d,e],type:p.TASKBOARD_TASK,previousItem:null,item:e};u.call(void 0,n)},[u,d]),H=t.useCallback((e,a)=>{const n=d.slice(),s=d.indexOf(a);s!==-1&&n.splice(s,1,e);const c={data:n,type:p.TASKBOARD_TASK,previousItem:a,item:e};u.call(void 0,c)},[u,d]),W=t.useCallback(e=>{const n={data:d.filter(s=>s!==e),type:p.TASKBOARD_TASK,previousItem:e,item:null};u.call(void 0,n)},[u,d]),F=t.useCallback((e,a)=>{const n=i.slice(),s=n.indexOf(a);s!==-1&&(e?n.splice(s,1,e):n.splice(s,1));const c={data:n,type:p.TASKBOARD_COLUMN,previousItem:a,item:e};u.call(void 0,c)},[u,i]);return t.createElement("div",{id:$,style:Z,ref:j,className:C.classNames("k-taskboard",V)},ee,t.createElement("div",{className:"k-taskboard-content",style:r?{userSelect:"none"}:void 0},t.createElement("div",{className:"k-taskboard-columns-container",ref:U},(x||i).map(e=>t.createElement(J.TaskBoardColumnBase,{key:e.id,tabIndex:o.tabIndex,column:e,tasks:A[e.status]||[],dragTargetRef:g,onTaskCreate:z,onTaskEdit:H,onTaskDelete:W,onColumnChange:F,columnComponent:o.column||Q.TaskBoardColumn,cardComponent:o.card||q.TaskBoardCard,priorities:o.priorities})))),r&&r.type===p.TASKBOARD_TASK&&t.createElement(ce.TaskBoardCardBase,{elementRef:P,style:{position:"absolute",width:r.width,height:r.height,top:I.top,left:I.left,zIndex:10,borderLeftColor:r.item.priority?r.item.priority.color:r.item.color},task:r.item,dragTargetRef:g,cardComponent:o.card||q.TaskBoardCard,onDeleteTask:C.noop,showEditPane:C.noop}),r&&r.type===p.TASKBOARD_COLUMN&&t.createElement(J.TaskBoardColumnBase,{elementRef:Y,style:{position:"absolute",width:r.width,height:r.height,top:I.top,left:I.left,zIndex:10},cardComponent:o.card||q.TaskBoardCard,columnComponent:o.column||Q.TaskBoardColumn,column:r.item,tasks:A[r.item.status],priorities:o.priorities,dragTargetRef:g,onTaskDelete:W,onColumnChange:F,onTaskEdit:H,onTaskCreate:z}),D&&t.createElement(C.WatermarkOverlay,null))});M.propTypes={columnData:G.array.isRequired,taskData:G.array.isRequired};M.displayName="KendoReactTaskBoard";exports.TaskBoard=M;
