/**
 * @license
 *-------------------------------------------------------------------------------------------
 * Copyright Â© 2025 Progress Software Corporation. All rights reserved.
 * Licensed under commercial license. See LICENSE.md in the package root for more information
 *-------------------------------------------------------------------------------------------
 */
import * as e from "react";
import W from "prop-types";
import { packageMetadata as it } from "./package-metadata.mjs";
import { validatePackage as ct, clone as F, useDraggable as lt, classNames as dt, noop as U, WatermarkOverlay as ut } from "@progress/kendo-react-common";
import { TaskBoardColumnBase as j } from "./TaskBoardColumnBase.mjs";
import { TaskBoardCardBase as mt } from "./TaskBoardCardBase.mjs";
import { TASKBOARD_COLUMN as T, TASKBOARD_PLACEHOLDER as ft, TASKBOARD_TASK as B } from "./constants.mjs";
import { closestTaskBoardElement as G, findIndexes as pt } from "./utils.mjs";
import { TaskBoardCard as N } from "./card/Card.mjs";
import { TaskBoardColumn as J } from "./column/Column.mjs";
const Q = e.forwardRef((c, V) => {
  const Z = !ct(it, { component: "TaskBoard" }), { columnData: f = [], className: $, style: tt, id: et, taskData: l = [], onChange: d } = c, K = e.useRef(null), L = e.useRef(null);
  e.useImperativeHandle(K, () => ({ props: c })), e.useImperativeHandle(V, () => K.current);
  const nt = e.Children.toArray(c.children).filter(
    (t) => t && t.type && t.type.displayName === "KendoReactTaskBoardToolbar"
  ), M = e.useRef(null), p = e.useRef(null), x = e.useRef(null), [C, w] = e.useState(null), [D, A] = e.useState(null), [I, P] = e.useState({ top: 0, left: 0 }), [at, X] = e.useState(), O = e.useRef(null), Y = e.useRef(null), b = e.useMemo(() => {
    const t = {};
    return (C || l).forEach((a) => {
      const n = a.status;
      t[n] || (t[n] = []), t[n].push(a);
    }), t;
  }, [l, C]), st = e.useCallback(
    (t) => {
      const a = t.originalEvent.target;
      if (a.closest("button,input,.k-link,.k-taskboard-preview-pane"))
        return;
      const n = G(a), s = L.current;
      if (n && s) {
        const r = n.type === T;
        if (r && !a.closest(".k-taskboard-column-header"))
          return;
        const R = n.element.getBoundingClientRect(), y = s.getBoundingClientRect();
        x.current = {
          x: t.clientX - R.left + y.left,
          y: t.clientY - R.top + y.top
        };
        const u = r ? f : l, S = r ? A : w, m = u.findIndex((v) => String(v.id) === n.id), k = u[m];
        if (m === -1 || k.edit)
          return;
        const i = F(k);
        i.isPlaceholder = !0;
        const h = [...u];
        h[m] = i, p.current = {
          ...n,
          index: m,
          item: k,
          width: R.width,
          height: R.height
        }, X(m), P({
          top: t.clientY - x.current.y,
          left: t.clientX - x.current.x
        }), S(h);
      }
    },
    [f, l]
  ), ot = e.useCallback(
    (t) => {
      const a = p.current, n = O.current && O.current.element || Y.current;
      if (a && n) {
        P({
          top: t.clientY - x.current.y,
          left: t.clientX - x.current.x
        }), n.style.visibility = "hidden";
        const s = document.elementFromPoint(t.clientX, t.clientY);
        if (n.style.visibility = "", s && s.getAttribute(ft))
          return;
        const r = s && G(s);
        if (r) {
          let g;
          const R = r.type === a.type, y = a.type === T, u = (y ? D : C) || [], S = y ? A : w;
          if (y || R) {
            if (g = pt(a.id, r.id, u), g) {
              const m = u[g.dragIndex], k = u[g.dropIndex], i = F(m);
              y || (i.status = k.status);
              const h = [...u];
              h.splice(g.dragIndex, 1), h.splice(g.dropIndex, 0, i), a.index = g.dropIndex, S(h);
            }
          } else {
            const m = u.findIndex((i) => String(i.id) === a.id), k = f.findIndex((i) => String(i.id) === r.id);
            if (m !== -1 && k !== -1) {
              const i = u[m], v = f[k].status;
              if (b[v])
                return;
              i.status = v;
              const E = [...u];
              E.splice(m, 1), E.push(i), a.index = E.length - 1, S(E);
            }
          }
        }
      }
    },
    [D, C, f, b]
  ), rt = e.useCallback(() => {
    const t = p.current;
    if (d && t) {
      const n = (t.type === T ? D : C) || [], s = n[t.index];
      delete s.isPlaceholder;
      const r = {
        data: n,
        type: t.type,
        previousItem: { ...t.item, index: at },
        item: { ...s, index: t.index }
      };
      d.call(void 0, r);
    }
    p.current = null, x.current = null, w(null), A(null), P({ top: 0, left: 0 }), X(void 0);
  }, [D, C, d]);
  lt(M, {
    onDragStart: st,
    onDrag: ot,
    onDragEnd: rt
  });
  const o = p.current, H = e.useCallback(
    (t) => {
      const n = {
        data: [...l, t],
        type: B,
        previousItem: null,
        item: t
      };
      d.call(void 0, n);
    },
    [d, l]
  ), _ = e.useCallback(
    (t, a) => {
      const n = l.slice(), s = l.indexOf(a);
      s !== -1 && n.splice(s, 1, t);
      const r = {
        data: n,
        type: B,
        previousItem: a,
        item: t
      };
      d.call(void 0, r);
    },
    [d, l]
  ), q = e.useCallback(
    (t) => {
      const n = {
        data: l.filter((s) => s !== t),
        type: B,
        previousItem: t,
        item: null
      };
      d.call(void 0, n);
    },
    [d, l]
  ), z = e.useCallback(
    (t, a) => {
      const n = f.slice(), s = n.indexOf(a);
      s !== -1 && (t ? n.splice(s, 1, t) : n.splice(s, 1));
      const r = {
        data: n,
        type: T,
        previousItem: a,
        item: t
      };
      d.call(void 0, r);
    },
    [d, f]
  );
  return /* @__PURE__ */ e.createElement("div", { id: et, style: tt, ref: L, className: dt("k-taskboard", $) }, nt, /* @__PURE__ */ e.createElement("div", { className: "k-taskboard-content", style: o ? { userSelect: "none" } : void 0 }, /* @__PURE__ */ e.createElement("div", { className: "k-taskboard-columns-container", ref: M }, (D || f).map((t) => /* @__PURE__ */ e.createElement(
    j,
    {
      key: t.id,
      tabIndex: c.tabIndex,
      column: t,
      tasks: b[t.status] || [],
      dragTargetRef: p,
      onTaskCreate: H,
      onTaskEdit: _,
      onTaskDelete: q,
      onColumnChange: z,
      columnComponent: c.column || J,
      cardComponent: c.card || N,
      priorities: c.priorities
    }
  )))), o && o.type === B && /* @__PURE__ */ e.createElement(
    mt,
    {
      elementRef: O,
      style: {
        position: "absolute",
        width: o.width,
        height: o.height,
        top: I.top,
        left: I.left,
        zIndex: 10,
        borderLeftColor: o.item.priority ? o.item.priority.color : o.item.color
      },
      task: o.item,
      dragTargetRef: p,
      cardComponent: c.card || N,
      onDeleteTask: U,
      showEditPane: U
    }
  ), o && o.type === T && /* @__PURE__ */ e.createElement(
    j,
    {
      elementRef: Y,
      style: {
        position: "absolute",
        width: o.width,
        height: o.height,
        top: I.top,
        left: I.left,
        zIndex: 10
      },
      cardComponent: c.card || N,
      columnComponent: c.column || J,
      column: o.item,
      tasks: b[o.item.status],
      priorities: c.priorities,
      dragTargetRef: p,
      onTaskDelete: q,
      onColumnChange: z,
      onTaskEdit: _,
      onTaskCreate: H
    }
  ), Z && /* @__PURE__ */ e.createElement(ut, null));
});
Q.propTypes = {
  columnData: W.array.isRequired,
  taskData: W.array.isRequired
};
Q.displayName = "KendoReactTaskBoard";
export {
  Q as TaskBoard
};
